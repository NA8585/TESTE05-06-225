<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Overlay Relative Aprimorada (iRacing Data)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet"/>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css"/>
    <script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>
    <style>
        /* Estilos Globais da Overlay */
        html, body {
            margin:0;
            padding:0;
            width:100vw;
            height:100vh;
            background:transparent !important;
            color:#fff;
            font-family:'Poppins',sans-serif;
            -webkit-user-select:none;
            overflow:hidden;
        }

        .resizable-overlay-wrapper {
            position: absolute; /* Posição absoluta para fácil localização */
            top: 50px; /* Inicia a 50px do topo */
            left: 50px; /* Inicia a 50px da esquerda */
            width:480px;
            height:450px;
            min-width:450px; /* Largura mínima ajustada para compactação */
            min-height:460px; /* Altura mínima ajustada para compactação */
            background:rgb(17,24,39);
            border:2px solid #3b82f6;
            border-radius:1rem;
            box-shadow:0 4px 10px rgba(0,0,0,0.5);
            display:flex;
            flex-direction:column;
            overflow:hidden;
            resize: both; /* Permite redimensionar em todas as direções */
            transition: opacity 0.3s ease-in-out, filter 0.3s ease-in-out; /* Transições suaves para opacidade e contraste */
        }

        .overlay-container {
            flex:1;
            display:flex;
            flex-direction:column;
            overflow:hidden;
        }

        .overlay-header {
            display:flex;
            align-items:center;
            justify-content:space-between;
            padding:3px 8px; /* Altura reduzida */
            background:inherit;
            cursor:move; /* Indica que o cabeçalho pode ser arrastado */
            -webkit-app-region:drag; /* Para arrastar a janela em ambientes como Electron */
            border-top-left-radius:0.875rem;
            border-top-right-radius:0.875rem;
            pointer-events: auto;
            border-bottom: 1px solid #334155;
        }

        .overlay-header .logo {
            display:flex;
            align-items:center;
            gap:4px;
            font-size:0.75rem;
            -webkit-app-region:no-drag; /* Exclui o logo da área de arrasto */
        }

        @keyframes pulse { /* Animação de pulsação para o ícone do headset */
            0% { transform: scale(1); opacity: 0.7; }
            50% { transform: scale(1.15); opacity: 1; }
            100% { transform: scale(1); opacity: 0.7; }
        }
        .pulsing-headset {
            animation: pulse 2s infinite ease-in-out;
        }

        @keyframes subtlePulse { /* Animação suave para o título "Relative" */
            0% { opacity: 0.8; }
            50% { opacity: 1; }
            100% { opacity: 0.8; }
        }

        .overlay-header .title {
            font-size:0.75rem;
            font-weight:600;
            white-space:nowrap;
            background:linear-gradient(to right, #00ffff, #00bfff);
            -webkit-background-clip:text;
            -webkit-text-fill-color:transparent;
            animation: subtlePulse 2s infinite ease-in-out;
        }

        .overlay-header .controls {
            display:flex;
            gap:4px;
            -webkit-app-region:no-drag; /* Exclui os controles da área de arrasto */
        }

        .overlay-header .controls button {
            background:#334155;
            border:none;
            padding:2px 4px;
            border-radius:4px;
            font-size:0.6rem;
            line-height: 1;
            cursor:pointer;
            transition:background 0.2s;
            pointer-events: auto;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
        }
        .overlay-header .controls button:hover {
            background:#475569;
        }
        .overlay-header #closeBtn { background:#dc2626;}
        .overlay-header #closeBtn:hover { background:#ef4444;}

        .relative-content-pane {
            flex-grow: 1;
            padding: 8px;
            overflow-y: hidden;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .header-bar, .footer-bar {
          display: flex;
          justify-content: space-around;
          align-items: center;
          padding: 0.4rem 0.6rem;
          font-size: 0.65rem;
          border-radius: 0.5rem;
          font-weight: 600;
          background-color: rgba(17, 24, 39, 0.85);
          color: #cbd5e1;
          backdrop-filter: blur(4px);
          width: 100%;
          box-sizing: border-box;
        }
        .header-bar div, .footer-bar div {
          padding: 0 0.3rem;
          white-space: nowrap;
        }

        #competitor-list-container {
          display: flex;
          flex-direction: column;
          gap: 3px;
          width: 100%;
          flex-grow: 1;
        }

        .driver-row {
          display: grid;
          /* Layout de colunas: Posição, Número do Carro, Pit Status, SR/iRating, Nome, Gap/Voltas */
          grid-template-columns: 25px 35px 35px 85px 1fr 80px;
          align-items: center;
          gap: 6px; /* Reduzido para acomodar a nova coluna */
          padding: 0.25rem 0.5rem;
          border-radius: 0.3rem;
          font-size: 0.75rem;
          height: 30px; /* Altura da linha ajustada para 30px */
          box-sizing: border-box;
          transition: background-color 0.2s ease, border-color 0.2s ease, color 0.2s ease, opacity 0.2s ease;
        }

        .highlight-self { /* Destaque para a linha do jogador */
          background-color: rgba(190, 242, 100, 0.25) !important;
          border: 1px solid transparent !important;
        }
        .highlight-self .driver-name {
            color: #bef264; 
            border: 1px solid #000000; 
            padding: 0 2px; 
            border-radius: 4px; 
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8); 
        }

        .driver-row.pit { /* Estilo para pilotos nos boxes */
            background-color: rgba(255, 193, 7, 0.1) !important; /* Fundo Ambar claro */
        }
        .pit-status {
            font-weight: bold;
            color: #FFC107; /* Ambar */
            text-align: center;
            font-size: 0.7rem;
        }


        .lap-ahead { /* Estilo para pilotos uma volta à frente (verde) */
            background-color: rgba(34, 197, 94, 0.15);
            border: 1px solid #22c55e;
            color: #bbf7d0;
            border-left: 3px solid #22c55e;
        }

        .lap-behind { /* Estilo para pilotos uma volta atrás (vermelho) */
            background-color: rgba(248, 113, 113, 0.15);
            border: 1px solid #f87171;
            color: #fecaca;
            border-left: 3px solid #f87171;
        }

        .same-lap { /* Estilo para carros na mesma volta (azul escuro transparente) */
            background-color: rgba(23, 37, 84, 0.7);
            border: 1px solid transparent;
            color: #e2e8f0;
            border-left: 3px solid rgba(23, 37, 84, 0.7);
        }

        .driver-row > span, .driver-row > div { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; display: flex; align-items: center; }
        .driver-row .pos { justify-content: center; }
        .driver-row .car-number { /* Cor será definida dinamicamente */ }
        .driver-row .driver-name { justify-content: flex-start; }
        .driver-row .rating-container {
            justify-content: center;
            gap: 4px;
            flex-wrap: nowrap;
            min-width: 60px;
            max-width: 85px; 
            overflow: hidden;
        }
        .driver-row .gap-time { 
            display: flex;
            align-items: center;
            justify-content: flex-end;
            font-size: 0.8rem;
            font-weight: 500;
            gap: 4px;
            height: 100%;
            flex-wrap: nowrap;
            min-width: 70px;
            max-width: 80px;
            overflow: hidden;
        }

        .gap-time-value { 
            padding: 2px 4px;
            border-radius: 4px;
            /* border: 1px solid transparent; Remove border specific to ahead/behind/pit from here */
            display: inline-flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
            box-sizing: border-box;
        }
        .gap-positive { color: #4ade80; /* Verde Tailwind green-400 */ }
        .gap-negative { color: #f87171; /* Vermelho Tailwind red-400 */ }


        .lap-diff-indicator {
            font-size: 0.7em;
            font-weight: bold;
            line-height: 1;
        }

        .badge { display: inline-block; padding: 0.1rem 0.3rem; border-radius: 0.2rem; font-size: 0.6rem; font-weight: bold; line-height: 1.2; box-sizing: border-box; white-space: nowrap; }
        .sr-badge { border: 1px solid; } 
        .sr-R { border-color: #ef4444; color: #ef4444; }
        .sr-D { border-color: #f97316; color: #f97316; }
        .sr-C { border-color: #facc15; color: #facc15; }
        .sr-B { border-color: #22c55e; color: #22c55e; }
        .sr-A { border-color: #3b82f6; color: #3b82f6; }
        .sr-P { border-color: #a855f7; color: #a855f7; }
        .sr-DEFAULT { border-color: #6b7280; color: #6b7280; }
        .irating-badge { background-color: #374151; color: #e5e7eb; }

        .car-number.category-GTP { color: #ef4444 !important; } 
        .car-number.category-LMP3 { color: #facc15 !important; } 
        .car-number.category-GT3 { color: #a855f7 !important; } 
        .car-number.category-GT4 { color: #2563eb !important; } 
        .car-number.category-default { color: #4b5563 !important; } 
        .car-number.single-class { color: #fff !important; } 
        .car-number.player-car-number { 
            color: #bef264 !important;
            text-shadow: 0 0 5px rgba(190, 242, 100, 0.8), 0 0 10px rgba(190, 242, 100, 0.6) !important;
        }
    </style>
<link rel="stylesheet" href="/index.css">
</head>
<body>
    <div class="resizable-overlay-wrapper" id="wrapper">
        <div class="overlay-container">
            <header class="overlay-header">
                <div class="logo">
                    <i class="fas fa-headset text-slate-400 pulsing-headset"></i>
                    <span style="color:#e2e8f0;">Coaching</span>
                    <span style="background:linear-gradient(to right,#ff0000,#fff,#00ff00);-webkit-background-clip:text;-webkit-text-fill-color:transparent; font-weight: 600;">NR85</span>
                    <span style="background:linear-gradient(to right,#00ffff,#00bfff);-webkit-background-clip:text;-webkit-text-fill-color:transparent;font-family:'Orbitron';font-weight:700;">IA</span>
                </div>
                <div class="title text-slate-200">Relative</div> 
                <div class="controls">
                    <button id="pinBtn" title="Fixar overlay (sobrepor janelas)">📌</button>
                    <button id="lockBtn" title="Bloquear/Desbloquear movimento e redimensionamento">🔒</button>
                    <button id="passThroughBtn" title="Ativar/Desativar passagem de clique">➡️</button>
                    <button id="settingsBtn" title="Ajustes">⚙️</button>
                    <button id="closeBtn" title="Fechar overlay">✖</button>
                </div>
            </header>

            <div id="settings-popover" class="hidden absolute top-10 right-2 bg-gray-800 p-4 rounded-lg shadow-lg z-10 w-64 -webkit-app-region:no-drag;">
                <h3 class="text-white text-md font-semibold mb-3">Configurações da Overlay</h3>
                <div class="mb-4">
                    <label for="rangeOpacity" class="block text-gray-300 text-sm font-bold mb-2">Opacidade:</label>
                    <input type="range" id="rangeOpacity" min="0.2" max="1" step="0.05" value="1" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                </div>
                <div class="mb-4">
                    <label for="rangeContrast" class="block text-gray-300 text-sm font-bold mb-2">Contraste:</label>
                    <input type="range" id="rangeContrast" min="0.5" max="2" step="0.05" value="1" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                </div>
            </div>

            <main class="relative-content-pane"> 
                <div class="header-bar">
                    <div id="raceName">Corrida: --</div>
                    <div id="raceTime">Sim: 00:00:00</div>
                    <div>Amb: <span id="ambientTemp">--</span>°C</div>
                    <div>Pista: <span id="trackTemp">--</span>°C</div>
                    <div>BB: <span id="brakeBias">--</span>%</div>
                </div>

                <div id="competitor-list-container"></div> 

                <div class="footer-bar">
                    <div>Sessão: <span id="sessionTimeRemaining">00:00:00</span></div>
                    <div>Voltas: <span id="lapsCompleted">--</span>/<span id="totalLaps">--</span></div>
                    <div id="penaltyStatus">Inc: --/--</div>
                </div>
            </main>
        </div>
    </div>

    <script>
        const WS_URL = window.OVERLAY_WS_URL || 'ws://localhost:5221/ws';
        let competitorListContainer = null;
        let websocket = null;

        let cachedDriverInfo = null;
        let cachedWeekendInfo = null;
        let cachedSessionInfo = null;
        let lastSessionInfoYaml = '';

        function parseYaml(yamlStr) {
            try {
                if (typeof jsyaml === 'undefined') {
                    console.error('Erro: jsyaml não está definido. Certifique-se de que a biblioteca js-yaml está carregada.');
                    return null;
                }
                return jsyaml.load(yamlStr.replace(/\0/g, ''));
            } catch (e) {
                console.error('Erro ao analisar YAML:', e);
                return null;
            }
        }

        function fmtTimeSimple(s) {
            if (typeof s !== 'number' || !isFinite(s) || s < 0 || s > 1e9) return '--:--:--';
            const date = new Date(s * 1000);
            const hh = date.getUTCHours().toString().padStart(2, '0');
            const mm = date.getUTCMinutes().toString().padStart(2, '0');
            const ss = date.getUTCSeconds().toString().padStart(2, '0');
            return `${hh}:${mm}:${ss}`;
        }

        function getSRClass(lic) {
            if (!lic) return 'sr-DEFAULT';
            const srPart = lic.split(' ')[0];
            return `sr-${srPart.charAt(0).toUpperCase()}` || 'sr-DEFAULT';
        }

        function getCarNumberColorClass(carClassShortName, numCarClasses) {
            if (numCarClasses === 1) {
                return 'single-class';
            }
            // Adjusted to match mock data CarClassShortName values
            switch (carClassShortName) {
                case 'GTP': return 'category-GTP';
                case 'LMP2': return 'category-LMP3'; // Using LMP3 color for LMP2 for now
                case 'GT3': return 'category-GT3';
                case 'GT4': return 'category-GT4';
                default: return 'category-default';
            }
        }


        function renderRelative(data) { 
            if (!competitorListContainer) {
                competitorListContainer = document.getElementById('competitor-list-container');
                if (!competitorListContainer) {
                    console.error("competitor-list-container não encontrado no DOM.");
                    return;
                }
            }

            if (!data) {
                competitorListContainer.innerHTML = `<div class="driver-row" style="justify-content: center;">Sem dados para exibir.</div>`;
                return;
            }
            // flatData is used to give preference to root properties (mock/TelemetryModel direct)
            // or properties from data.session / data.vehicle if they exist (TelemetryModel sub-objects)
            const flatData = { ...data, ...(data.session || {}), ...(data.vehicle || {}) };

            const sessionInfoYamlFromData = data.sessionInfoYaml || flatData.sessionInfoYaml;
            if (sessionInfoYamlFromData && sessionInfoYamlFromData !== lastSessionInfoYaml) {
                const parsed = parseYaml(sessionInfoYamlFromData);
                if (parsed) {
                    cachedDriverInfo = parsed.DriverInfo?.Drivers;
                    cachedWeekendInfo = parsed.WeekendInfo;
                    cachedSessionInfo = parsed.SessionInfo?.Sessions;
                }
                lastSessionInfoYaml = sessionInfoYamlFromData;
            }
            
            // Data Sourcing: Try direct on `data` (mock/TM), then TM sub-objects (via flatData), then FP sub-objects
            const currentSessionNum = flatData.sessionNum ?? data.telemetry?.sessionNum; // Assuming sessionNum might be in telemetry for FP
            const sessionType = (cachedSessionInfo || []).find(s => s.SessionNum === currentSessionNum)?.SessionType || data.sessionInfo?.sessionType || 'Practice';
            
            const trackDisplayNameValue = flatData.trackDisplayName ?? data.weekendInfo?.trackDisplayName ?? cachedWeekendInfo?.TrackDisplayName ?? '--';
            document.getElementById('raceName').textContent = `Corrida: ${trackDisplayNameValue}`;

            const sessionTimeValue = flatData.sessionTime ?? data.telemetry?.sessionTime;
            document.getElementById('raceTime').textContent = `Sim: ${fmtTimeSimple(sessionTimeValue)}`;
            
            const trackAirTempValue = data.airTemp ?? flatData.trackAirTemp ?? data.weekendInfo?.trackAirTemp;
            document.getElementById('ambientTemp').textContent = (typeof trackAirTempValue === 'number') ? trackAirTempValue.toFixed(1) : '--';

            const trackSurfaceTempValue = flatData.trackSurfaceTemp ?? data.telemetry?.trackTemp;
            document.getElementById('trackTemp').textContent = (typeof trackSurfaceTempValue === 'number' && trackSurfaceTempValue > -100) ? trackSurfaceTempValue.toFixed(1) : '--';
            
            const dcBrakeBiasValue = flatData.dcBrakeBias ?? data.telemetry?.dcBrakeBias;
            document.getElementById('brakeBias').textContent = `${typeof dcBrakeBiasValue === 'number' ? dcBrakeBiasValue.toFixed(1) : '--'}`;

            const sessionTimeRemainValue = flatData.sessionTimeRemain ?? data.telemetry?.sessionTimeRemain;
            document.getElementById('sessionTimeRemaining').textContent = `${fmtTimeSimple(sessionTimeRemainValue)}`;

            const lapCompletedValue = flatData.lap ?? data.telemetry?.lapCompleted ?? '--';
            document.getElementById('lapsCompleted').textContent = `${lapCompletedValue}`;

            let totalLapsCalculated;
            if (flatData.totalLaps !== undefined) { // Mock data or TM might have pre-calculated totalLaps
                totalLapsCalculated = flatData.totalLaps;
            } else if (data.sessionInfo?.currentSessionTotalLaps !== undefined) { // FP
                totalLapsCalculated = data.sessionInfo.currentSessionTotalLaps;
                 // If FP indicates 0 laps for a timed session, treat as unlimited for display.
                if (totalLapsCalculated === 0 && (cachedSessionInfo?.find(s => s.SessionNum === currentSessionNum)?.SessionTime.includes("sec")) && !(cachedSessionInfo?.find(s => s.SessionNum === currentSessionNum)?.SessionLaps.includes("laps"))) {
                    totalLapsCalculated = -1;
                }
            } else if (cachedSessionInfo) { // Fallback to YAML parsed info
                 const sessionLapsFromYaml = (cachedSessionInfo || []).find(s => s.SessionNum === currentSessionNum)?.SessionLaps;
                 if (sessionLapsFromYaml === "unlimited" || sessionLapsFromYaml === undefined) totalLapsCalculated = -1;
                 else totalLapsCalculated = parseInt(sessionLapsFromYaml);
            }
            const totalLapsDisplay = (totalLapsCalculated < 0 || isNaN(totalLapsCalculated)) ? '∞' : totalLapsCalculated;
            document.getElementById('totalLaps').textContent = `${totalLapsDisplay}`;
            
            const incidentLimitFromYaml = cachedWeekendInfo?.IncidentLimit;
            const incidentLimitLive = data.sessionInfo?.incidentLimit;
            const incidentLimitValue = incidentLimitFromYaml ?? incidentLimitLive;
            const incidentLimitDisplay = (incidentLimitValue === 'unlimited' || incidentLimitValue === 0 || incidentLimitValue === undefined) ? 'N/A' : incidentLimitValue;

            const playerCarIdxValue = flatData.playerCarIdx ?? data.telemetry?.playerCarIdx;
            let playerIncidentsValue = flatData.playerCarTeamIncidentCount ?? flatData.playerCarMyIncidentCount;
            if (playerIncidentsValue === undefined && data.telemetry?.playerCarMyIncidentCount !== undefined) {
                 playerIncidentsValue = data.telemetry.playerCarMyIncidentCount;
            } else if (playerIncidentsValue === undefined && data.drivers && playerCarIdxValue !== undefined) {
                 const playerDriverPayload = data.drivers.find(d => d.carIdx === playerCarIdxValue);
                 if (playerDriverPayload?.teamIncidentCount !== undefined) {
                    playerIncidentsValue = playerDriverPayload.teamIncidentCount;
                 } else if (playerDriverPayload?.myIncidentCount !== undefined) { // Assuming myIncidentCount could be on driver payload
                    playerIncidentsValue = playerDriverPayload.myIncidentCount;
                 }
            }
            document.getElementById('penaltyStatus').textContent = `Inc: ${playerIncidentsValue ?? '--'}/${incidentLimitDisplay}`;

            const driversFromYaml = cachedDriverInfo || [];
            const numCarClasses = cachedWeekendInfo?.NumCarClasses || 1;

            if (!driversFromYaml.length || playerCarIdxValue === undefined || !cachedWeekendInfo || !cachedSessionInfo) {
                competitorListContainer.innerHTML = `<div class="driver-row" style="justify-content: center;">Aguardando dados YAML...</div>`;
                return;
            }
            
            const { carIdxPosition, carIdxLap, carIdxOnPitRoad, carIdxTrackSurface, carIdxLapDistPct, carIdxBestLapTime, carIdxLastLapTime, carIdxF2Time, carIdxLapCompleted: carIdxLapCompletedArray } = flatData;

            // Preliminary check for essential telemetry arrays
            if (!Array.isArray(carIdxLapDistPct) || !Array.isArray(carIdxLap) || !Array.isArray(carIdxPosition)) {
                competitorListContainer.innerHTML = `<div class="driver-row" style="justify-content: center;">Dados de telemetria dos carros ausentes ou malformados.</div>`;
                return;
            }

            const allDriversMapped = driversFromYaml.map(dYaml => {
                const carIdx = dYaml?.CarIdx ?? -1;
                const surface = carIdxTrackSurface?.[carIdx] ?? -1; 
                const distPct = carIdxLapDistPct?.[carIdx] ?? -1;   
                
                const isActive = surface !== 4 && surface !== 5 && surface !== -1 && distPct >= 0; // Surface 4 & 5 considered inactive as per mock, -1 NotInWorld

                return {
                    idx: carIdx,
                    pos: carIdxPosition?.[carIdx] ?? 0,
                    name: dYaml?.UserName || '---',
                    num: dYaml?.CarNumberRaw || '--',
                    lap: carIdxLap?.[carIdx] ?? -1,
                    distPct: distPct,
                    onPit: carIdxOnPitRoad?.[carIdx] ?? false,
                    irating: dYaml?.IRating || 0,
                    lic: dYaml?.LicString || '',
                    carClassShortName: dYaml?.CarClassShortName || '',
                    estLap: parseFloat(dYaml?.CarClassEstLapTime) || 0,
                    bestLapTime: carIdxBestLapTime?.[carIdx] ?? 0,
                    lastLapTime: carIdxLastLapTime?.[carIdx] ?? 0,
                    pitTime: carIdxF2Time?.[carIdx] ?? 0,
                    tireCompound: dYaml?.TireCompound || '---',
                    stintLaps: carIdxLapCompletedArray?.[carIdx] ?? (flatData.carIdxLapCompleted?.[carIdx]) ?? 0,
                    surface: surface, 
                    isActive: isActive,
                    effectiveGap: undefined, 
                    timeGap: undefined,      
                    lapDiff: undefined       
                };
            });

            const player = allDriversMapped.find(d => d.idx === playerCarIdxValue);
            if (!player) { 
                competitorListContainer.innerHTML = `<div class="driver-row" style="justify-content: center;">Dados do jogador (CarIdx: ${playerCarIdxValue}) não encontrados na lista YAML.</div>`;
                return;
            }
             if (!player.isActive) {
                competitorListContainer.innerHTML = `<div class="driver-row" style="justify-content: center;">Jogador (CarIdx: ${playerCarIdxValue}) inativo ou fora da pista.</div>`;
                createRelativeRow(player, player, sessionType, numCarClasses); // Still render player's row if found, even if inactive
                return;
            }
            player.timeGap = 0; 
            player.lapDiff = 0;
            player.effectiveGap = 0;


            const trackLen = (parseFloat(cachedWeekendInfo?.TrackLength) * 1000) || 4000; 
            const playerEstLap = player.estLap || 120; 

            const activeOthers = allDriversMapped.filter(d => d.idx !== player.idx && d.isActive);

            activeOthers.forEach(d => {
                const otherCarEstLapTime = d.estLap || playerEstLap; 

                const playerDistAbsolute = (player.lap * trackLen) + (player.distPct * trackLen);
                const otherDistAbsolute = (d.lap * trackLen) + (d.distPct * trackLen);

                d.effectiveGap = (otherDistAbsolute - playerDistAbsolute) / (trackLen / otherCarEstLapTime);
                d.lapDiff = (d.lap || 0) - (player.lap || 0);

                if (d.carClassShortName === player.carClassShortName) {
                    let normalizedShortestGap = d.effectiveGap - (d.lapDiff * otherCarEstLapTime);
                    if (normalizedShortestGap > otherCarEstLapTime / 1.95) { 
                        normalizedShortestGap -= otherCarEstLapTime;
                    } else if (normalizedShortestGap < -otherCarEstLapTime / 1.95) { 
                        normalizedShortestGap += otherCarEstLapTime;
                    }
                    d.timeGap = normalizedShortestGap; // Sign is determined by normalizedShortestGap itself
                } else {
                    d.timeGap = undefined; 
                }
            });
            
            competitorListContainer.innerHTML = ''; // Clear previous entries

            if (activeOthers.length === 0) {
                createRelativeRow(player, player, sessionType, numCarClasses); // Render player
                const messageDiv = document.createElement('div');
                messageDiv.className = 'driver-row';
                messageDiv.style.justifyContent = 'center';
                messageDiv.textContent = 'Aguardando outros pilotos ativos...';
                competitorListContainer.appendChild(messageDiv);
                return;
            }
            
            const carsPhysicallyAhead = activeOthers
                .filter(d => d.effectiveGap !== undefined && d.effectiveGap > 0)
                .sort((a, b) => a.effectiveGap - b.effectiveGap); 

            const carsPhysicallyBehind = activeOthers
                .filter(d => d.effectiveGap !== undefined && d.effectiveGap < 0)
                .sort((a, b) => Math.abs(a.effectiveGap) - Math.abs(b.effectiveGap)); 

            const N_DISPLAY = 5;
            const potential_ahead_list = carsPhysicallyAhead.slice(0, N_DISPLAY);
            const potential_behind_list = carsPhysicallyBehind.slice(0, N_DISPLAY);
            
            let render_count_ahead = potential_ahead_list.length;
            let render_count_behind = potential_behind_list.length;

            if (render_count_ahead > render_count_behind + 1 && render_count_ahead > N_DISPLAY /2) { // Try to balance more if list is larger
                render_count_ahead = Math.min(render_count_ahead, render_count_behind + 1);
            } else if (render_count_behind > render_count_ahead + 1 && render_count_behind > N_DISPLAY /2) {
                render_count_behind = Math.min(render_count_behind, render_count_ahead + 1);
            }


            const ahead_to_render = potential_ahead_list.slice(0, render_count_ahead).reverse(); 
            const behind_to_render = potential_behind_list.slice(0, render_count_behind);


            for (const car of ahead_to_render) { 
                createRelativeRow(car, player, sessionType, numCarClasses);
            }
            createRelativeRow(player, player, sessionType, numCarClasses); 
            for (const car of behind_to_render) { 
                createRelativeRow(car, player, sessionType, numCarClasses);
            }
        }

        function createRelativeRow(car, player, sessionType, numCarClasses) {
            const el = document.createElement('div');
            let classes = 'driver-row';

            if (car.idx === player.idx) {
                classes += ' highlight-self';
            } else {
                 // Determine class based on lap difference for Race, otherwise default
                if (sessionType === 'Race' && car.lapDiff !== undefined && car.lapDiff !== null) {
                    if (car.lapDiff > 0) classes += ' lap-ahead';
                    else if (car.lapDiff < 0) classes += ' lap-behind';
                    else classes += ' same-lap';
                } else {
                    classes += ' same-lap'; // Default for non-Race or undefined lapDiff
                }
            }


            if (car.onPit) classes += ' pit';
            el.className = classes;

            let gapText;
            let gapTextColorClass = '';
            let lapDiffIndicator = '';

            if (car.idx === player.idx) {
                gapText = '0.0';
            } else if (car.timeGap === undefined || car.timeGap === null) { 
                gapText = '---';
            } else { 
                gapText = (car.timeGap > 0 ? '+' : '') + car.timeGap.toFixed(1);
                if (car.timeGap > 0) {
                    gapTextColorClass = 'gap-positive';
                } else if (car.timeGap < 0) {
                    gapTextColorClass = 'gap-negative';
                }
            }
            
            if (sessionType === 'Race' && car.lapDiff !== 0 && car.lapDiff !== undefined && car.lapDiff !== null) {
                const signedLapDiff = car.lapDiff > 0 ? `+${car.lapDiff}L` : `${car.lapDiff}L`;
                lapDiffIndicator = `<span class="lap-diff-indicator">${signedLapDiff}</span>`;
            }

            const irating = car.irating > 0 ? `${(car.irating / 1000).toFixed(1)}k` : '---';
            let carNumberColorClass = getCarNumberColorClass(car.carClassShortName, numCarClasses);
            
            if (car.idx === player.idx) {
                carNumberColorClass = 'player-car-number';
            }
            
            const pitStatusText = car.onPit ? 'PIT' : '';

            el.innerHTML = `
                <span class="pos">${car.pos || '--'}</span>
                <span class="car-number ${carNumberColorClass}">#${car.num}</span>
                <span class="pit-status">${pitStatusText}</span>
                <div class="rating-container">
                    <span class="sr-badge badge ${getSRClass(car.lic)}">${car.lic || '--'}</span>
                    <span class="irating-badge badge">${irating}</span>
                </div>
                <span class="driver-name">${car.name}</span>
                <span class="gap-time">
                    <span class="gap-time-value ${gapTextColorClass}">${gapText}</span>
                    ${lapDiffIndicator}
                </span>`;
            competitorListContainer.appendChild(el);
        }

        function connectWS() {
            if (websocket && (websocket.readyState === WebSocket.OPEN || websocket.readyState === WebSocket.CONNECTING)) {
                console.log("WebSocket já está conectado ou conectando.");
                return;
            }

            websocket = new WebSocket(WS_URL);

            websocket.onopen = () => {
                console.log('Conectado ao Backend WebSocket:', WS_URL);
                if (competitorListContainer) {
                     competitorListContainer.innerHTML = `<div class="driver-row" style="justify-content: center;">Conectado. Aguardando dados...</div>`;
                }
            };

            websocket.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    renderRelative(data);
                } catch (e) {
                    console.error('Erro ao processar mensagem do WebSocket:', e);
                     if (competitorListContainer) {
                        competitorListContainer.innerHTML = `<div class="driver-row" style="justify-content: center;">Erro ao processar dados.</div>`;
                    }
                }
            };

            websocket.onerror = (error) => {
                console.error('Erro no WebSocket:', error);
                if (competitorListContainer) {
                    competitorListContainer.innerHTML = `<div class="driver-row" style="justify-content: center;">Erro de conexão. Tentando reconectar...</div>`;
                }
            };

            websocket.onclose = (event) => {
                console.log('WebSocket desconectado:', event.code, event.reason);
                if (competitorListContainer) {
                    const message = event.wasClean ? 'Desconectado.' : 'Conexão perdida.';
                    competitorListContainer.innerHTML = `<div class="driver-row" style="justify-content: center;">${message} Tentando reconectar em 3s...</div>`;
                }

                // Only attempt to reconnect if it wasn't a clean close (e.g., user closed the overlay)
                // or if the server explicitly indicates an issue that might be resolvable by reconnecting.
                if (event.code !== 1000 && event.code !== 1001 && event.code !== 1005 ) { // 1000: Normal, 1001: Going Away, 1005: No Status Recvd
                     setTimeout(connectWS, 3000);
                } else if (!event.wasClean) { // If not clean and also not one of the above, still try.
                     setTimeout(connectWS, 3000);
                }

            };
        }


        document.addEventListener('DOMContentLoaded', () => {
            const settingsPopover = document.getElementById('settings-popover');
            const settingsBtn = document.getElementById('settingsBtn');
            const wrapper = document.getElementById('wrapper');
            const lockBtn = document.getElementById('lockBtn');

            competitorListContainer = document.getElementById('competitor-list-container');

            if (settingsBtn) {
                settingsBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    settingsPopover.classList.toggle('hidden');
                });
            }
            document.addEventListener('click', (e) => {
                if (settingsPopover && !settingsPopover.classList.contains('hidden') && !settingsPopover.contains(e.target) && e.target !== settingsBtn) {
                    settingsPopover.classList.add('hidden');
                }
            });

            document.getElementById('rangeOpacity')?.addEventListener('input', (e) => wrapper.style.opacity = e.target.value);
            document.getElementById('rangeContrast')?.addEventListener('input', (e) => wrapper.style.filter = `contrast(${e.target.value})`);

            document.getElementById('closeBtn')?.addEventListener('click', () => {
                if (websocket && websocket.readyState === WebSocket.OPEN) {
                    websocket.close(1000, "User closed overlay"); 
                }
                if (window.overlayAPI && window.overlayAPI.close) {
                    window.overlayAPI.close();
                } else {
                    try { window.close(); } catch (e) { console.warn("window.close() failed.")}
                }
            });

            let isLocked = false;
            if (lockBtn) {
                lockBtn.addEventListener('click', (e) => {
                    isLocked = !isLocked;
                    wrapper.style.webkitAppRegion = isLocked ? 'no-drag' : 'drag';
                    wrapper.style.resize = isLocked ? 'none' : 'both';
                    e.currentTarget.innerHTML = isLocked ? '🔓' : '🔒';
                });
            }

            document.getElementById('pinBtn')?.addEventListener('click', () => {
                alert('A funcionalidade "Sobrepor todas as janelas" (Always On Top) geralmente requer permissões do sistema operacional ou um ambiente de aplicativo nativo (como Electron ou NW.js) para funcionar. Em um navegador web padrão, esta função não é diretamente suportada.');
            });

            document.getElementById('passThroughBtn')?.addEventListener('click', () => {
                alert('A funcionalidade de "Passagem de Clique" (Click-Through) geralmente requer permissões do sistema operacional ou um ambiente de aplicativo nativo (como Electron ou NW.js) para funcionar. Em um navegador web padrão, esta função não é diretamente suportada.');
            });

            connectWS(); 
        });
    </script>
    <!-- <script type="module" src="index.js"></script> --> 
<script type="module" src="/index.tsx"></script>
</body>
</html>
