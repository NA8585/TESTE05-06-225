<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Overlay Relative Aprimorada (iRacing Data)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet"/>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css"/>
    <script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>
    <style>
        /* Estilos Globais da Overlay */
        html, body {
            margin:0;
            padding:0;
            width:100vw;
            height:100vh;
            background:transparent !important;
            color:#fff;
            font-family:'Poppins',sans-serif;
            -webkit-user-select:none;
            overflow:hidden;
        }

        .resizable-overlay-wrapper {
            position: absolute; /* Posi√ß√£o absoluta para f√°cil localiza√ß√£o */
            top: 50px; /* Inicia a 50px do topo */
            left: 50px; /* Inicia a 50px da esquerda */
            width:480px;
            height:450px;
            min-width:450px; /* Largura m√≠nima ajustada para compacta√ß√£o */
            min-height:460px; /* Altura m√≠nima ajustada para compacta√ß√£o */
            background:rgb(17,24,39);
            border:2px solid #3b82f6;
            border-radius:1rem;
            box-shadow:0 4px 10px rgba(0,0,0,0.5);
            display:flex;
            flex-direction:column;
            overflow:hidden;
            resize: both; /* Permite redimensionar em todas as dire√ß√µes */
            transition: opacity 0.3s ease-in-out, filter 0.3s ease-in-out; /* Transi√ß√µes suaves para opacidade e contraste */
        }

        .overlay-container {
            flex:1;
            display:flex;
            flex-direction:column;
            overflow:hidden;
        }

        .overlay-header {
            display:flex;
            align-items:center;
            justify-content:space-between;
            padding:3px 8px; /* Altura reduzida */
            background:inherit;
            cursor:move; /* Indica que o cabe√ßalho pode ser arrastado */
            -webkit-app-region:drag; /* Para arrastar a janela em ambientes como Electron */
            border-top-left-radius:0.875rem;
            border-top-right-radius:0.875rem;
            pointer-events: auto;
            border-bottom: 1px solid #334155;
        }

        .overlay-header .logo {
            display:flex;
            align-items:center;
            gap:4px;
            font-size:0.75rem;
            -webkit-app-region:no-drag; /* Exclui o logo da √°rea de arrasto */
        }

        @keyframes pulse { /* Anima√ß√£o de pulsa√ß√£o para o √≠cone do headset */
            0% { transform: scale(1); opacity: 0.7; }
            50% { transform: scale(1.15); opacity: 1; }
            100% { transform: scale(1); opacity: 0.7; }
        }
        .pulsing-headset {
            animation: pulse 2s infinite ease-in-out;
        }

        @keyframes subtlePulse { /* Anima√ß√£o suave para o t√≠tulo "Relative" */
            0% { opacity: 0.8; }
            50% { opacity: 1; }
            100% { opacity: 0.8; }
        }

        .overlay-header .title {
            font-size:0.75rem;
            font-weight:600;
            white-space:nowrap;
            background:linear-gradient(to right, #00ffff, #00bfff);
            -webkit-background-clip:text;
            -webkit-text-fill-color:transparent;
            animation: subtlePulse 2s infinite ease-in-out;
        }

        .overlay-header .controls {
            display:flex;
            gap:4px;
            -webkit-app-region:no-drag; /* Exclui os controles da √°rea de arrasto */
        }

        .overlay-header .controls button {
            background:#334155;
            border:none;
            padding:2px 4px;
            border-radius:4px;
            font-size:0.6rem;
            line-height: 1;
            cursor:pointer;
            transition:background 0.2s;
            pointer-events: auto;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
        }
        .overlay-header .controls button:hover {
            background:#475569;
        }
        .overlay-header #closeBtn { background:#dc2626;}
        .overlay-header #closeBtn:hover { background:#ef4444;}

        .relative-content-pane {
            flex-grow: 1;
            padding: 8px;
            overflow-y: hidden;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .header-bar, .footer-bar {
          display: flex;
          justify-content: space-around;
          align-items: center;
          padding: 0.4rem 0.6rem;
          font-size: 0.65rem;
          border-radius: 0.5rem;
          font-weight: 600;
          background-color: rgba(17, 24, 39, 0.85);
          color: #cbd5e1;
          backdrop-filter: blur(4px);
          width: 100%;
          box-sizing: border-box;
        }
        .header-bar div, .footer-bar div {
          padding: 0 0.3rem;
          white-space: nowrap;
        }

        #competitor-list-container {
          display: flex;
          flex-direction: column;
          gap: 3px;
          width: 100%;
          flex-grow: 1;
        }

        .driver-row {
          display: grid;
          /* Layout de colunas: Posi√ß√£o, N√∫mero do Carro, Pit Status, SR/iRating, Nome, Gap/Voltas */
          grid-template-columns: 25px 35px 35px 85px 1fr 80px;
          align-items: center;
          gap: 6px; /* Reduzido para acomodar a nova coluna */
          padding: 0.25rem 0.5rem;
          border-radius: 0.3rem;
          font-size: 0.75rem;
          height: 30px; /* Altura da linha ajustada para 30px */
          box-sizing: border-box;
          transition: background-color 0.2s ease, border-color 0.2s ease, color 0.2s ease, opacity 0.2s ease;
        }

        .highlight-self { /* Destaque para a linha do jogador */
          background-color: rgba(190, 242, 100, 0.25) !important;
          border: 1px solid transparent !important;
        }
        .highlight-self .driver-name {
            color: #bef264; 
            border: 1px solid #000000; 
            padding: 0 2px; 
            border-radius: 4px; 
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8); 
        }

        .driver-row.pit { /* Estilo para pilotos nos boxes */
            background-color: rgba(255, 193, 7, 0.1) !important; /* Fundo Ambar claro */
        }
        .pit-status {
            font-weight: bold;
            color: #FFC107; /* Ambar */
            text-align: center;
            font-size: 0.7rem;
        }


        .lap-ahead { /* Estilo para pilotos uma volta √† frente (verde) */
            background-color: rgba(34, 197, 94, 0.15);
            border: 1px solid #22c55e;
            color: #bbf7d0;
            border-left: 3px solid #22c55e;
        }

        .lap-behind { /* Estilo para pilotos uma volta atr√°s (vermelho) */
            background-color: rgba(248, 113, 113, 0.15);
            border: 1px solid #f87171;
            color: #fecaca;
            border-left: 3px solid #f87171;
        }

        .same-lap { /* Estilo para carros na mesma volta (azul escuro transparente) */
            background-color: rgba(23, 37, 84, 0.7);
            border: 1px solid transparent;
            color: #e2e8f0;
            border-left: 3px solid rgba(23, 37, 84, 0.7);
        }

        .driver-row > span, .driver-row > div { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; display: flex; align-items: center; }
        .driver-row .pos { justify-content: center; }
        .driver-row .car-number { /* Cor ser√° definida dinamicamente */ }
        .driver-row .driver-name { justify-content: flex-start; }
        .driver-row .rating-container {
            justify-content: center;
            gap: 4px;
            flex-wrap: nowrap;
            min-width: 60px;
            max-width: 85px; 
            overflow: hidden;
        }
        .driver-row .gap-time { 
            display: flex;
            align-items: center;
            justify-content: flex-end;
            font-size: 0.8rem;
            font-weight: 500;
            gap: 4px;
            height: 100%;
            flex-wrap: nowrap;
            min-width: 70px;
            max-width: 80px;
            overflow: hidden;
        }

        .gap-time-value { 
            padding: 2px 4px;
            border-radius: 4px;
            /* border: 1px solid transparent; Remove border specific to ahead/behind/pit from here */
            display: inline-flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
            box-sizing: border-box;
        }
        .gap-positive { color: #4ade80; /* Verde Tailwind green-400 */ }
        .gap-negative { color: #f87171; /* Vermelho Tailwind red-400 */ }


        .lap-diff-indicator {
            font-size: 0.7em;
            font-weight: bold;
            line-height: 1;
        }

        .badge { display: inline-block; padding: 0.1rem 0.3rem; border-radius: 0.2rem; font-size: 0.6rem; font-weight: bold; line-height: 1.2; box-sizing: border-box; white-space: nowrap; }
        .sr-badge { border: 1px solid; } 
        .sr-R { border-color: #ef4444; color: #ef4444; }
        .sr-D { border-color: #f97316; color: #f97316; }
        .sr-C { border-color: #facc15; color: #facc15; }
        .sr-B { border-color: #22c55e; color: #22c55e; }
        .sr-A { border-color: #3b82f6; color: #3b82f6; }
        .sr-P { border-color: #a855f7; color: #a855f7; }
        .sr-DEFAULT { border-color: #6b7280; color: #6b7280; }
        .irating-badge { background-color: #374151; color: #e5e7eb; }

        .car-number.category-GTP { color: #ef4444 !important; } 
        .car-number.category-LMP3 { color: #facc15 !important; } 
        .car-number.category-GT3 { color: #a855f7 !important; } 
        .car-number.category-GT4 { color: #2563eb !important; } 
        .car-number.category-default { color: #4b5563 !important; } 
        .car-number.single-class { color: #fff !important; } 
        .car-number.player-car-number { 
            color: #bef264 !important;
            text-shadow: 0 0 5px rgba(190, 242, 100, 0.8), 0 0 10px rgba(190, 242, 100, 0.6) !important;
        }
    </style>
<link rel="stylesheet" href="/index.css">
</head>
<body>
    <div class="resizable-overlay-wrapper" id="wrapper">
        <div class="overlay-container">
            <header class="overlay-header">
                <div class="logo">
                    <i class="fas fa-headset text-slate-400 pulsing-headset"></i>
                    <span style="color:#e2e8f0;">Coaching</span>
                    <span style="background:linear-gradient(to right,#ff0000,#fff,#00ff00);-webkit-background-clip:text;-webkit-text-fill-color:transparent; font-weight: 600;">NR85</span>
                    <span style="background:linear-gradient(to right,#00ffff,#00bfff);-webkit-background-clip:text;-webkit-text-fill-color:transparent;font-family:'Orbitron';font-weight:700;">IA</span>
                </div>
                <div class="title text-slate-200">Relative</div> 
                <div class="controls">
                    <button id="pinBtn" title="Fixar overlay (sobrepor janelas)">üìå</button>
                    <button id="lockBtn" title="Bloquear/Desbloquear movimento e redimensionamento">üîí</button>
                    <button id="passThroughBtn" title="Ativar/Desativar passagem de clique">‚û°Ô∏è</button>
                    <button id="settingsBtn" title="Ajustes">‚öôÔ∏è</button>
                    <button id="closeBtn" title="Fechar overlay">‚úñ</button>
                </div>
            </header>

            <div id="settings-popover" class="hidden absolute top-10 right-2 bg-gray-800 p-4 rounded-lg shadow-lg z-10 w-64 -webkit-app-region:no-drag;">
                <h3 class="text-white text-md font-semibold mb-3">Configura√ß√µes da Overlay</h3>
                <div class="mb-4">
                    <label for="rangeOpacity" class="block text-gray-300 text-sm font-bold mb-2">Opacidade:</label>
                    <input type="range" id="rangeOpacity" min="0.2" max="1" step="0.05" value="1" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                </div>
                <div class="mb-4">
                    <label for="rangeContrast" class="block text-gray-300 text-sm font-bold mb-2">Contraste:</label>
                    <input type="range" id="rangeContrast" min="0.5" max="2" step="0.05" value="1" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                </div>
            </div>

            <main class="relative-content-pane"> 
                <div class="header-bar">
                    <div id="raceName">Corrida: --</div>
                    <div id="raceTime">Sim: 00:00:00</div>
                    <div>Amb: <span id="ambientTemp">--</span>¬∞C</div>
                    <div>Pista: <span id="trackTemp">--</span>¬∞C</div>
                    <div>BB: <span id="brakeBias">--</span>%</div>
                </div>

                <div id="competitor-list-container"></div> 

                <div class="footer-bar">
                    <div>Sess√£o: <span id="sessionTimeRemaining">00:00:00</span></div>
                    <div>Voltas: <span id="lapsCompleted">--</span>/<span id="totalLaps">--</span></div>
                    <div id="penaltyStatus">Inc: --/--</div>
                </div>
            </main>
        </div>
    </div>

    <script>
        const WS_URL = window.OVERLAY_WS_URL || 'ws://localhost:5221/ws';
        let competitorListContainer = null;
        let websocket = null;

        let cachedDriverInfo = null;
        let cachedWeekendInfo = null;
        let cachedSessionInfo = null;
        let lastSessionInfoYaml = '';

        function parseYaml(yamlStr) {
            try {
                if (typeof jsyaml === 'undefined') {
                    console.error('Erro: jsyaml n√£o est√° definido. Certifique-se de que a biblioteca js-yaml est√° carregada.');
                    return null;
                }
                return jsyaml.load(yamlStr.replace(/\0/g, ''));
            } catch (e) {
                console.error('Erro ao analisar YAML:', e);
                return null;
            }
        }

        function fmtTimeSimple(s) {
            if (typeof s !== 'number' || !isFinite(s) || s < 0 || s > 1e9) return '--:--:--';
            const date = new Date(s * 1000);
            const hh = date.getUTCHours().toString().padStart(2, '0');
            const mm = date.getUTCMinutes().toString().padStart(2, '0');
            const ss = date.getUTCSeconds().toString().padStart(2, '0');
            return `${hh}:${mm}:${ss}`;
        }

        function getSRClass(lic) {
            if (!lic) return 'sr-DEFAULT';
            const srPart = lic.split(' ')[0];
            return `sr-${srPart.charAt(0).toUpperCase()}` || 'sr-DEFAULT';
        }

        function getCarNumberColorClass(carClassShortName, numCarClasses) {
            if (numCarClasses === 1) {
                return 'single-class';
            }
            // Adjusted to match mock data CarClassShortName values
            switch (carClassShortName) {
                case 'GTP': return 'category-GTP';
                case 'LMP2': return 'category-LMP3'; // Using LMP3 color for LMP2 for now
                case 'GT3': return 'category-GT3';
                case 'GT4': return 'category-GT4';
                default: return 'category-default';
            }
        }


        function renderRelative(data) { 
            if (!competitorListContainer) {
                competitorListContainer = document.getElementById('competitor-list-container');
                if (!competitorListContainer) {
                    console.error("competitor-list-container n√£o encontrado no DOM.");
                    return;
                }
            }

            if (!data) {
                competitorListContainer.innerHTML = `<div class="driver-row" style="justify-content: center;">Sem dados para exibir.</div>`;
                return;
            }
            // flatData is used to give preference to root properties (mock/TelemetryModel direct)
            // or properties from data.session / data.vehicle if they exist (TelemetryModel sub-objects)
            const flatData = { ...data, ...(data.session || {}), ...(data.vehicle || {}) };

            const sessionInfoYamlFromData = data.sessionInfoYaml || flatData.sessionInfoYaml;
            if (sessionInfoYamlFromData && sessionInfoYamlFromData !== lastSessionInfoYaml) {
                const parsed = parseYaml(sessionInfoYamlFromData);
                if (parsed) {
                    cachedDriverInfo = parsed.DriverInfo?.Drivers;
                    cachedWeekendInfo = parsed.WeekendInfo;
                    cachedSessionInfo = parsed.SessionInfo?.Sessions;
                }
                lastSessionInfoYaml = sessionInfoYamlFromData;
            }
            
            // Data Sourcing: Try direct on `data` (mock/TM), then TM sub-objects (via flatData), then FP sub-objects
            const currentSessionNum = flatData.sessionNum ?? data.telemetry?.sessionNum; // Assuming sessionNum might be in telemetry for FP
            const sessionType = (cachedSessionInfo || []).find(s => s.SessionNum === currentSessionNum)?.SessionType || data.sessionInfo?.sessionType || 'Practice';
            
            const trackDisplayNameValue = flatData.trackDisplayName ?? data.weekendInfo?.trackDisplayName ?? cachedWeekendInfo?.TrackDisplayName ?? '--';
            document.getElementById('raceName').textContent = `Corrida: ${trackDisplayNameValue}`;

            const sessionTimeValue = flatData.sessionTime ?? data.telemetry?.sessionTime;
            document.getElementById('raceTime').textContent = `Sim: ${fmtTimeSimple(sessionTimeValue)}`;
            
            const trackAirTempValue = data.airTemp ?? flatData.trackAirTemp ?? data.weekendInfo?.trackAirTemp;
            document.getElementById('ambientTemp').textContent = (typeof trackAirTempValue === 'number') ? trackAirTempValue.toFixed(1) : '--';

            const trackSurfaceTempValue = flatData.trackSurfaceTemp ?? data.telemetry?.trackTemp;
            document.getElementById('trackTemp').textContent = (typeof trackSurfaceTempValue === 'number' && trackSurfaceTempValue > -100) ? trackSurfaceTempValue.toFixed(1) : '--';
            
            const dcBrakeBiasValue = flatData.dcBrakeBias ?? data.telemetry?.dcBrakeBias;
            document.getElementById('brakeBias').textContent = `${typeof dcBrakeBiasValue === 'number' ? dcBrakeBiasValue.toFixed(1) : '--'}`;

            const sessionTimeRemainValue = flatData.sessionTimeRemain ?? data.telemetry?.sessionTimeRemain;
            document.getElementById('sessionTimeRemaining').textContent = `${fmtTimeSimple(sessionTimeRemainValue)}`;

            const lapCompletedValue = flatData.lap ?? data.telemetry?.lapCompleted ?? '--';
            document.getElementById('lapsCompleted').textContent = `${lapCompletedValue}`;

            let totalLapsCalculated;
            if (flatData.totalLaps !== undefined) { // Mock data or TM might have pre-calculated totalLaps
                totalLapsCalculated = flatData.totalLaps;
            } else if (data.sessionInfo?.currentSessionTotalLaps !== undefined) { // FP
                totalLapsCalculated = data.sessionInfo.currentSessionTotalLaps;
                 // If FP indicates 0 laps for a timed session, treat as unlimited for display.
                if (totalLapsCalculated === 0 && (cachedSessionInfo?.find(s => s.SessionNum === currentSessionNum)?.SessionTime.includes("sec")) && !(cachedSessionInfo?.find(s => s.SessionNum === currentSessionNum)?.SessionLaps.includes("laps"))) {
                    totalLapsCalculated = -1;
                }
            } else if (cachedSessionInfo) { // Fallback to YAML parsed info
                 const sessionLapsFromYaml = (cachedSessionInfo || []).find(s => s.SessionNum === currentSessionNum)?.SessionLaps;
                 if (sessionLapsFromYaml === "unlimited" || sessionLapsFromYaml === undefined) totalLapsCalculated = -1;
                 else totalLapsCalculated = parseInt(sessionLapsFromYaml);
            }
            const totalLapsDisplay = (totalLapsCalculated < 0 || isNaN(totalLapsCalculated)) ? '‚àû' : totalLapsCalculated;
            document.getElementById('totalLaps').textContent = `${totalLapsDisplay}`;
            
            const incidentLimitFromYaml = cachedWeekendInfo?.IncidentLimit;
            const incidentLimitLive = data.sessionInfo?.incidentLimit;
            const incidentLimitValue = incidentLimitFromYaml ?? incidentLimitLive;
            const incidentLimitDisplay = (incidentLimitValue === 'unlimited' || incidentLimitValue === 0 || incidentLimitValue === undefined) ? 'N/A' : incidentLimitValue;

            const playerCarIdxValue = flatData.playerCarIdx ?? data.telemetry?.playerCarIdx;
            let playerIncidentsValue = flatData.playerCarTeamIncidentCount ?? flatData.playerCarMyIncidentCount;
            if (playerIncidentsValue === undefined && data.telemetry?.playerCarMyIncidentCount !== undefined) {
                 playerIncidentsValue = data.telemetry.playerCarMyIncidentCount;
            } else if (playerIncidentsValue === undefined && data.drivers && playerCarIdxValue !== undefined) {
                 const playerDriverPayload = data.drivers.find(d => d.carIdx === playerCarIdxValue);
                 if (playerDriverPayload?.teamIncidentCount !== undefined) {
                    playerIncidentsValue = playerDriverPayload.teamIncidentCount;
                 } else if (playerDriverPayload?.myIncidentCount !== undefined) { // Assuming myIncidentCount could be on driver payload
                    playerIncidentsValue = playerDriverPayload.myIncidentCount;
                 }
            }
            document.getElementById('penaltyStatus').textContent = `Inc: ${playerIncidentsValue ?? '--'}/${incidentLimitDisplay}`;

            const driversFromYaml = cachedDriverInfo || [];
            const numCarClasses = cachedWeekendInfo?.NumCarClasses || 1;

            if (!driversFromYaml.length || playerCarIdxValue === undefined || !cachedWeekendInfo || !cachedSessionInfo) {
                competitorListContainer.innerHTML = `<div class="driver-row" style="justify-content: center;">Aguardando dados YAML...</div>`;
                return;
            }
            
            const { carIdxPosition, carIdxLap, carIdxOnPitRoad, carIdxTrackSurface, carIdxLapDistPct, carIdxBestLapTime, carIdxLastLapTime, carIdxF2Time, carIdxLapCompleted: carIdxLapCompletedArray } = flatData;

            // Preliminary check for essential telemetry arrays
            if (!Array.isArray(carIdxLapDistPct) || !Array.isArray(carIdxLap) || !Array.isArray(carIdxPosition)) {
                competitorListContainer.innerHTML = `<div class="driver-row" style="justify-content: center;">Dados de telemetria dos carros ausentes ou malformados.</div>`;
                return;
            }

            const allDriversMapped = driversFromYaml.map(dYaml => {
                const carIdx = dYaml?.CarIdx ?? -1;
                const surface = carIdxTrackSurface?.[carIdx] ?? -1; 
                const distPct = carIdxLapDistPct?.[carIdx] ?? -1;   
                
                const isActive = surface !== 4 && surface !== 5 && surface !== -1 && distPct >= 0; // Surface 4 & 5 considered inactive as per mock, -1 NotInWorld

                return {
                    idx: carIdx,
                    pos: carIdxPosition?.[carIdx] ?? 0,
                    name: dYaml?.UserName || '---',
                    num: dYaml?.CarNumberRaw || '--',
                    lap: carIdxLap?.[carIdx] ?? -1,
                    distPct: distPct,
                    onPit: carIdxOnPitRoad?.[carIdx] ?? false,
                    irating: dYaml?.IRating || 0,
                    lic: dYaml?.LicString || '',
                    carClassShortName: dYaml?.CarClassShortName || '',
                    estLap: parseFloat(dYaml?.CarClassEstLapTime) || 0,
                    bestLapTime: carIdxBestLapTime?.[carIdx] ?? 0,
                    lastLapTime: carIdxLastLapTime?.[carIdx] ?? 0,
                    pitTime: carIdxF2Time?.[carIdx] ?? 0,
                    tireCompound: dYaml?.TireCompound || '---',
                    stintLaps: carIdxLapCompletedArray?.[carIdx] ?? (flatData.carIdxLapCompleted?.[carIdx]) ?? 0,
                    surface: surface, 
                    isActive: isActive,
                    effectiveGap: undefined, 
                    timeGap: undefined,      
                    lapDiff: undefined       
                };
            });

            const player = allDriversMapped.find(d => d.idx === playerCarIdxValue);
            if (!player) { 
                competitorListContainer.innerHTML = `<div class="driver-row" style="justify-content: center;">Dados do jogador (CarIdx: ${playerCarIdxValue}) n√£o encontrados na lista YAML.</div>`;
                return;
            }
             if (!player.isActive) {
                competitorListContainer.innerHTML = `<div class="driver-row" style="justify-content: center;">Jogador (CarIdx: ${playerCarIdxValue}) inativo ou fora da pista.</div>`;
                createRelativeRow(player, player, sessionType, numCarClasses); // Still render player's row if found, even if inactive
                return;
            }
            player.timeGap = 0; 
            player.lapDiff = 0;
            player.effectiveGap = 0;


            const trackLen = (parseFloat(cachedWeekendInfo?.TrackLength) * 1000) || 4000; 
            const playerEstLap = player.estLap || 120; 

            const activeOthers = allDriversMapped.filter(d => d.idx !== player.idx && d.isActive);

            activeOthers.forEach(d => {
                const otherCarEstLapTime = d.estLap || playerEstLap; 

                const playerDistAbsolute = (player.lap * trackLen) + (player.distPct * trackLen);
                const otherDistAbsolute = (d.lap * trackLen) + (d.distPct * trackLen);

                d.effectiveGap = (otherDistAbsolute - playerDistAbsolute) / (trackLen / otherCarEstLapTime);
                d.lapDiff = (d.lap || 0) - (player.lap || 0);

                if (d.carClassShortName === player.carClassShortName) {
                    let normalizedShortestGap = d.effectiveGap - (d.lapDiff * otherCarEstLapTime);
                    if (normalizedShortestGap > otherCarEstLapTime / 1.95) { 
                        normalizedShortestGap -= otherCarEstLapTime;
                    } else if (normalizedShortestGap < -otherCarEstLapTime / 1.95) { 
                        normalizedShortestGap += otherCarEstLapTime;
                    }
                    d.timeGap = normalizedShortestGap; // Sign is determined by normalizedShortestGap itself
                } else {
                    d.timeGap = undefined; 
                }
            });
            
            competitorListContainer.innerHTML = ''; // Clear previous entries

            if (activeOthers.length === 0) {
                createRelativeRow(player, player, sessionType, numCarClasses); // Render player
                const messageDiv = document.createElement('div');
                messageDiv.className = 'driver-row';
                messageDiv.style.justifyContent = 'center';
                messageDiv.textContent = 'Aguardando outros pilotos ativos...';
                competitorListContainer.appendChild(messageDiv);
                return;
            }
            
            const carsPhysicallyAhead = activeOthers
                .filter(d => d.effectiveGap !== undefined && d.effectiveGap > 0)
                .sort((a, b) => a.effectiveGap - b.effectiveGap); 

            const carsPhysicallyBehind = activeOthers
                .filter(d => d.effectiveGap !== undefined && d.effectiveGap < 0)
                .sort((a, b) => Math.abs(a.effectiveGap) - Math.abs(b.effectiveGap)); 

            const N_DISPLAY = 5;
            const potential_ahead_list = carsPhysicallyAhead.slice(0, N_DISPLAY);
            const potential_behind_list = carsPhysicallyBehind.slice(0, N_DISPLAY);
            
            let render_count_ahead = potential_ahead_list.length;
            let render_count_behind = potential_behind_list.length;

            if (render_count_ahead > render_count_behind + 1 && render_count_ahead > N_DISPLAY /2) { // Try to balance more if list is larger
                render_count_ahead = Math.min(render_count_ahead, render_count_behind + 1);
            } else if (render_count_behind > render_count_ahead + 1 && render_count_behind > N_DISPLAY /2) {
                render_count_behind = Math.min(render_count_behind, render_count_ahead + 1);
            }


            const ahead_to_render = potential_ahead_list.slice(0, render_count_ahead).reverse(); 
            const behind_to_render = potential_behind_list.slice(0, render_count_behind);


            for (const car of ahead_to_render) { 
                createRelativeRow(car, player, sessionType, numCarClasses);
            }
            createRelativeRow(player, player, sessionType, numCarClasses); 
            for (const car of behind_to_render) { 
                createRelativeRow(car, player, sessionType, numCarClasses);
            }
        }

        function createRelativeRow(car, player, sessionType, numCarClasses) {
            const el = document.createElement('div');
            let classes = 'driver-row';

            if (car.idx === player.idx) {
                classes += ' highlight-self';
            } else {
                 // Determine class based on lap difference for Race, otherwise default
                if (sessionType === 'Race' && car.lapDiff !== undefined && car.lapDiff !== null) {
                    if (car.lapDiff > 0) classes += ' lap-ahead';
                    else if (car.lapDiff < 0) classes += ' lap-behind';
                    else classes += ' same-lap';
                } else {
                    classes += ' same-lap'; // Default for non-Race or undefined lapDiff
                }
            }


            if (car.onPit) classes += ' pit';
            el.className = classes;

            let gapText;
            let gapTextColorClass = '';
            let lapDiffIndicator = '';

            if (car.idx === player.idx) {
                gapText = '0.0';
            } else if (car.timeGap === undefined || car.timeGap === null) { 
                gapText = '---';
            } else { 
                gapText = (car.timeGap > 0 ? '+' : '') + car.timeGap.toFixed(1);
                if (car.timeGap > 0) {
                    gapTextColorClass = 'gap-positive';
                } else if (car.timeGap < 0) {
                    gapTextColorClass = 'gap-negative';
                }
            }
            
            if (sessionType === 'Race' && car.lapDiff !== 0 && car.lapDiff !== undefined && car.lapDiff !== null) {
                const signedLapDiff = car.lapDiff > 0 ? `+${car.lapDiff}L` : `${car.lapDiff}L`;
                lapDiffIndicator = `<span class="lap-diff-indicator">${signedLapDiff}</span>`;
            }

            const irating = car.irating > 0 ? `${(car.irating / 1000).toFixed(1)}k` : '---';
            let carNumberColorClass = getCarNumberColorClass(car.carClassShortName, numCarClasses);
            
            if (car.idx === player.idx) {
                carNumberColorClass = 'player-car-number';
            }
            
            const pitStatusText = car.onPit ? 'PIT' : '';

            el.innerHTML = `
                <span class="pos">${car.pos || '--'}</span>
                <span class="car-number ${carNumberColorClass}">#${car.num}</span>
                <span class="pit-status">${pitStatusText}</span>
                <div class="rating-container">
                    <span class="sr-badge badge ${getSRClass(car.lic)}">${car.lic || '--'}</span>
                    <span class="irating-badge badge">${irating}</span>
                </div>
                <span class="driver-name">${car.name}</span>
                <span class="gap-time">
                    <span class="gap-time-value ${gapTextColorClass}">${gapText}</span>
                    ${lapDiffIndicator}
                </span>`;
            competitorListContainer.appendChild(el);
        }

        function connectWS() {
            if (websocket && (websocket.readyState === WebSocket.OPEN || websocket.readyState === WebSocket.CONNECTING)) {
                console.log("WebSocket j√° est√° conectado ou conectando.");
                return;
            }

            websocket = new WebSocket(WS_URL);

            websocket.onopen = () => {
                console.log('Conectado ao Backend WebSocket:', WS_URL);
                if (competitorListContainer) {
                     competitorListContainer.innerHTML = `<div class="driver-row" style="justify-content: center;">Conectado. Aguardando dados...</div>`;
                }
            };

            websocket.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    renderRelative(data);
                } catch (e) {
                    console.error('Erro ao processar mensagem do WebSocket:', e);
                     if (competitorListContainer) {
                        competitorListContainer.innerHTML = `<div class="driver-row" style="justify-content: center;">Erro ao processar dados.</div>`;
                    }
                }
            };

            websocket.onerror = (error) => {
                console.error('Erro no WebSocket:', error);
                if (competitorListContainer) {
                    competitorListContainer.innerHTML = `<div class="driver-row" style="justify-content: center;">Erro de conex√£o. Tentando reconectar...</div>`;
                }
            };

            websocket.onclose = (event) => {
                console.log('WebSocket desconectado:', event.code, event.reason);
                if (competitorListContainer) {
                    const message = event.wasClean ? 'Desconectado.' : 'Conex√£o perdida.';
                    competitorListContainer.innerHTML = `<div class="driver-row" style="justify-content: center;">${message} Tentando reconectar em 3s...</div>`;
                }

                // Only attempt to reconnect if it wasn't a clean close (e.g., user closed the overlay)
                // or if the server explicitly indicates an issue that might be resolvable by reconnecting.
                if (event.code !== 1000 && event.code !== 1001 && event.code !== 1005 ) { // 1000: Normal, 1001: Going Away, 1005: No Status Recvd
                     setTimeout(connectWS, 3000);
                } else if (!event.wasClean) { // If not clean and also not one of the above, still try.
                     setTimeout(connectWS, 3000);
                }

            };
        }


        document.addEventListener('DOMContentLoaded', () => {
            const settingsPopover = document.getElementById('settings-popover');
            const settingsBtn = document.getElementById('settingsBtn');
            const wrapper = document.getElementById('wrapper');
            const lockBtn = document.getElementById('lockBtn');

            competitorListContainer = document.getElementById('competitor-list-container');

            if (settingsBtn) {
                settingsBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    settingsPopover.classList.toggle('hidden');
                });
            }
            document.addEventListener('click', (e) => {
                if (settingsPopover && !settingsPopover.classList.contains('hidden') && !settingsPopover.contains(e.target) && e.target !== settingsBtn) {
                    settingsPopover.classList.add('hidden');
                }
            });

            document.getElementById('rangeOpacity')?.addEventListener('input', (e) => wrapper.style.opacity = e.target.value);
            document.getElementById('rangeContrast')?.addEventListener('input', (e) => wrapper.style.filter = `contrast(${e.target.value})`);

            document.getElementById('closeBtn')?.addEventListener('click', () => {
                if (websocket && websocket.readyState === WebSocket.OPEN) {
                    websocket.close(1000, "User closed overlay"); 
                }
                if (window.overlayAPI && window.overlayAPI.close) {
                    window.overlayAPI.close();
                } else {
                    try { window.close(); } catch (e) { console.warn("window.close() failed.")}
                }
            });

            let isLocked = false;
            if (lockBtn) {
                lockBtn.addEventListener('click', (e) => {
                    isLocked = !isLocked;
                    wrapper.style.webkitAppRegion = isLocked ? 'no-drag' : 'drag';
                    wrapper.style.resize = isLocked ? 'none' : 'both';
                    e.currentTarget.innerHTML = isLocked ? 'üîì' : 'üîí';
                });
            }

            document.getElementById('pinBtn')?.addEventListener('click', () => {
                alert('A funcionalidade "Sobrepor todas as janelas" (Always On Top) geralmente requer permiss√µes do sistema operacional ou um ambiente de aplicativo nativo (como Electron ou NW.js) para funcionar. Em um navegador web padr√£o, esta fun√ß√£o n√£o √© diretamente suportada.');
            });

            document.getElementById('passThroughBtn')?.addEventListener('click', () => {
                alert('A funcionalidade de "Passagem de Clique" (Click-Through) geralmente requer permiss√µes do sistema operacional ou um ambiente de aplicativo nativo (como Electron ou NW.js) para funcionar. Em um navegador web padr√£o, esta fun√ß√£o n√£o √© diretamente suportada.');
            });

            connectWS(); 
        });
    </script>
    <!-- <script type="module" src="index.js"></script> --> 
<script type="module" src="/index.tsx"></script>
</body>
</html>
