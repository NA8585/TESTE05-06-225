<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Overlay de Dados do Piloto</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet"/>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css"/>
    <style>
        /* CSS para o corpo e a overlay */
        html, body {
            margin:0;
            padding:0;
            width:100vw;
            height:100vh;
            background:transparent; /* Fundo transparente para a overlay */
            color:#fff; /* Cor do texto padr√£o */
            font-family:'Poppins',sans-serif; /* Fonte principal */
            -webkit-user-select:none; /* Desabilita sele√ß√£o de texto */
            overflow:hidden; /* Esconde overflow */
        }

        /* Estilo do wrapper da overlay redimension√°vel */
        .resizable-overlay-wrapper {
            position:absolute;
            top:0;
            left:0;
            width:400px; /* Largura inicial */
            height:220px; /* Altura inicial */
            min-width:280px; /* Largura m√≠nima */
            min-height:120px; /* Altura m√≠nima */
            background:rgb(17,24,39); /* Cor de fundo escura */
            border:2px solid #3b82f6; /* Borda azul */
            border-radius:1rem; /* Cantos arredondados */
            box-shadow:0 4px 10px rgba(0,0,0,0.5); /* Sombra */
            display:flex;
            flex-direction:column;
            overflow:hidden;
            -webkit-app-region:drag; /* Permite arrastar a janela no Electron */
        }

        /* Estilo dos manipuladores de redimensionamento */
        .resize-handle {
            position:absolute;
            width:15px;
            height:15px;
            z-index:1001; /* Acima de outros elementos */
            background:transparent; /* Transparente para n√£o bloquear o conte√∫do */
            -webkit-app-region:no-drag; /* Desabilita arrasto da janela nos manipuladores */
            pointer-events: auto; /* Garante que as al√ßas sejam clic√°veis mesmo com click-through */
        }

        /* Posi√ß√£o e cursor para cada manipulador */
        .resize-handle.top-left    { top:0; left:0; cursor:nwse-resize; }
        .resize-handle.top-center  { top:0; left:50%; transform:translateX(-50%); cursor:ns-resize; }
        .resize-handle.top-right   { top:0; right:0; cursor:nesw-resize; }
        .resize-handle.right-center{ top:50%; right:0; transform:translateY(-50%); cursor:ew-resize; }
        .resize-handle.bottom-right{ bottom:0; right:0; cursor:se-resize; }
        .resize-handle.bottom-center{ bottom:0; left:50%; transform:translateX(-50%); cursor:ns-resize; }
        .resize-handle.bottom-left { bottom:0; left:0; cursor:sw-resize; }
        .resize-handle.left-center { top:50%; left:0; transform:translateY(-50%); cursor:ew-resize; }

        /* Container principal do conte√∫do da overlay */
        .overlay-container {
            flex:1;
            display:flex;
            flex-direction:column;
            overflow:hidden;
        }

        /* Cabe√ßalho da overlay */
        .header {
            display:flex;
            align-items:center;
            justify-content:space-between;
            padding:4px 8px;
            background:inherit; /* Herda o fundo do pai */
            cursor:move; /* Cursor de movimento */
            -webkit-app-region:drag; /* Permite arrastar a janela no cabe√ßalho */
            border-top-left-radius:1rem;
            border-top-right-radius:1rem;
            pointer-events: auto; /* Garante que o cabe√ßalho seja clic√°vel mesmo com click-through */
        }

        /* Logo no cabe√ßalho */
        .header .logo {
            display:flex;
            align-items:center;
            gap:4px;
            font-size:0.75rem;
            -webkit-app-region:no-drag; /* Desabilita arrasto da janela na logo */
        }

        /* T√≠tulo no cabe√ßalho */
        .header .title {
            font-size:0.75rem;
            font-weight:600;
            white-space:nowrap;
        }

        /* Controles (bot√µes) no cabe√ßalho */
        .controls {
            display:flex;
            gap:4px;
            -webkit-app-region:no-drag; /* Desabilita arrasto da janela nos controles */
        }

        /* Estilo dos bot√µes de controle */
        .controls button {
            background:#334155; /* Cor de fundo padr√£o */
            border:none;
            padding:2px 4px;
            border-radius:4px;
            font-size:0.6rem;
            cursor:pointer;
            transition:background 0.2s; /* Transi√ß√£o suave no hover */
            pointer-events: auto; /* Garante que os bot√µes sejam clic√°veis mesmo com click-through */
        }
        .controls button:hover {
            background:#475569; /* Cor de fundo no hover */
        }
        #closeBtn { background:#dc2626;} /* Cor do bot√£o de fechar */
        #closeBtn:hover { background:#ef4444;} /* Cor do bot√£o de fechar no hover */

        /* Conte√∫do principal dos inputs */
        .overlay-inputs-content {
            flex:1;
            display:flex;
            flex-direction:column;
            justify-content:flex-start; /* Alinha o conte√∫do ao in√≠cio */
            padding:4px;
            background:inherit;
            box-sizing:border-box;
            overflow:hidden;
            pointer-events: auto; /* Garante que o conte√∫do seja clic√°vel mesmo com click-through */
            padding-top: 0px; /* Removido o padding-top para n√£o ter espa√ßo sobrando */
        }

        /* Container de cada barra de input */
        .bar-container {
            margin-bottom:6px; /* Ajustado para 6px de espa√ßo entre as barras */
            position:relative;
        }
        /* A primeira barra n√£o ter√° margin-top para ficar mais pr√≥xima do cabe√ßalho */
        .bar-container:first-of-type {
            margin-top: 3px; /* Espa√ßo de 3px do cabe√ßalho */
        }


        /* Fundo da barra de input */
        .bar-bg {
            width:100%;
            height:14px; /* Altura mantida em 14px */
            background:#111827; /* Cor de fundo da barra */
            border-radius:6px;
            overflow:hidden;
            position:relative;
        }

        /* Preenchimento da barra de input */
        .bar-fill {
            height:100%;
            transition:width 0.1s ease-out; /* Transi√ß√£o suave na largura */
        }

        /* R√≥tulo da barra (valor percentual) */
        .bar-label {
            position:absolute;
            top:50%;
            transform:translateY(-50%); /* Mant√©m o alinhamento vertical */
            font-size:0.6rem;
            color:#fff;
            pointer-events:none; /* Permite cliques atrav√©s do r√≥tulo */
            white-space: nowrap; /* Impede que o texto quebre */
        }

        /* Canvas para a timeline dos inputs */
        #inputTimelineCanvas {
            width:100%;
            height:106px; /* Altura mantida */
            margin-top:4px;
            border:2px solid #3b82f6; /* Borda azul */
            border-radius:6px;
        }

        /* Estilo dos r√≥tulos no popover de ajustes */
        #settings-popover {
            position:absolute; top:40px; right:10px;
            display:none; /* Inicialmente oculto */
            background-color:rgba(30,41,59,0.95); /* Fundo semi-transparente */
            border:1px solid #3b82f6; border-radius:0.5rem;
            padding:0.6rem; z-index:1000;
            pointer-events: auto; /* Garante que o popover seja clic√°vel mesmo com click-through */
        }
        #settings-popover label {
            color:#cbd5e1;
            font-size:0.7rem;
        }
    </style>
</head>

<body>
    <div class="resizable-overlay-wrapper" id="wrapper">
        <div class="resize-handle top-left" id="h-tl"></div>
        <div class="resize-handle top-center" id="h-tc"></div>
        <div class="resize-handle top-right" id="h-tr"></div>
        <div class="resize-handle right-center" id="h-rc"></div>
        <div class="resize-handle bottom-right" id="h-br"></div>
        <div class="resize-handle bottom-center" id="h-bc"></div>
        <div class="resize-handle bottom-left" id="h-bl"></div>
        <div class="resize-handle left-center" id="h-lc"></div>

        <div class="overlay-container">
            <div class="header">
                <div class="logo">
                    <i class="fas fa-headset"></i> Coaching
                    <span style="background:linear-gradient(to right,#ff0000,#fff,#00ff00);-webkit-background-clip:text;-webkit-text-fill-color:transparent;">NR85</span>
                    <span style="background:linear-gradient(to right,#00ffff,#00bfff);-webkit-background-clip:text;-webkit-text-fill-color:transparent;font-family:'Orbitron';font-weight:700;">IA</span>
                </div>
                <div class="title">Inputs do Piloto</div>
                <div class="controls">
                    <button id="pin" title="Sempre vis√≠vel">üìå</button>
                    <button id="lock" title="Travar/Destravar posi√ß√£o">üîí</button>
                    <button id="click" title="Ignorar cliques">üñ±Ô∏è</button>
                    <button id="gear" title="Ajustes">‚öôÔ∏è</button>
                    <button id="closeBtn" title="Fechar overlay">‚úñ</button>
                </div>
            </div>
            <div class="overlay-inputs-content">
                <div class="bar-container">
                    <div class="bar-bg">
                        <div id="input-throttle" class="bar-fill bg-green-500" style="width:0%;"></div>
                        <div class="bar-label" id="throttle-value">0%</div>
                    </div>
                </div>
                <div class="bar-container">
                    <div class="bar-bg">
                        <div id="input-brake" class="bar-fill bg-red-500" style="width:0%;"></div>
                        <div class="bar-label" id="brake-value">0%</div>
                    </div>
                </div>
                <div class="bar-container">
                    <div class="bar-bg">
                        <div id="input-steer" class="bar-fill bg-blue-500" style="width:0%;"></div>
                        <div class="bar-label" id="steer-value">0%</div>
                    </div>
                </div>
                <canvas id="inputTimelineCanvas"></canvas>
            </div>
        </div>
    </div>

    <div id="settings-popover"
        style="position:absolute; top:40px; right:10px; display:none; background-color:rgba(30,41,59,0.95); border:1px solid #3b82f6; border-radius:0.5rem; padding:0.6rem; z-index:1000;">
        <div style="margin-bottom:0.4rem;">
            <label for="rangeOpacity">Opacidade</label>
            <input type="range" id="rangeOpacity" min="0.1" max="1" step="0.01" value="0.98" style="width:100%;">
        </div>
        <div>
            <label for="rangeContrast">Contraste</label>
            <input type="range" id="rangeContrast" min="0.5" max="2" step="0.01" value="1" style="width:100%;">
        </div>
    </div>
    <script>
        // Nome √∫nico para esta overlay para salvar/carregar configura√ß√µes
        const OVERLAY_NAME = 'overlay-inputs';

        // Refer√™ncia ao wrapper principal da overlay
        const resizableOverlayWrapper = document.getElementById('wrapper');
        const overlayContent = document.querySelector('.overlay-inputs-content'); // Conte√∫do principal da overlay

        // Vari√°veis de estado para redimensionamento
        let isResizing = false;
        let resizeHandleType = '';
        let initialX, initialY;
        let initialWidth, initialHeight;
        let initialLeft, initialTop;

        // Vari√°veis de estado para arrasto
        let isDragging = false;
        let dragStartX, dragStartY;
        let windowStartX, windowStartY;

        // Fun√ß√£o para obter o cursor correto para cada dire√ß√£o de redimensionamento
        function getCursorForHandle(handleType) {
            switch (handleType) {
                case 'tl': return 'nwse-resize';
                case 'tc': return 'ns-resize';
                case 'tr': return 'nesw-resize';
                case 'rc': return 'ew-resize';
                case 'br': return 'se-resize';
                case 'bc': return 'ns-resize';
                case 'bl': return 'sw-resize';
                case 'lc': return 'ew-resize';
                default: return 'default';
            }
        }

        // Adiciona event listeners aos manipuladores de redimensionamento
        document.querySelectorAll('.resize-handle').forEach(handle => {
            handle.addEventListener('mousedown', async (e) => {
                e.preventDefault();
                e.stopPropagation();

                if (locked) return; // N√£o redimensiona se estiver bloqueado

                isResizing = true;
                resizeHandleType = handle.id.replace('h-', '');
                initialX = e.clientX;
                initialY = e.clientY;

                if (window.electronAPI && window.electronAPI.getBounds) {
                    const bounds = await window.electronAPI.getBounds(OVERLAY_NAME); // Passa o nome da overlay
                    initialWidth = bounds.width;
                    initialHeight = bounds.height;
                    initialLeft = bounds.x;
                    initialTop = bounds.y;
                } else {
                    const rect = resizableOverlayWrapper.getBoundingClientRect();
                    initialWidth = rect.width;
                    initialHeight = rect.height;
                    initialLeft = rect.left;
                    initialTop = rect.top;
                }

                document.body.style.cursor = getCursorForHandle(resizeHandleType);
            });
        });

        // L√≥gica de redimensionamento
        function resize(e, handleType) {
            if (!isResizing) return;

            const aspectRatio = initialWidth / initialHeight;
            const shiftPressed = e.shiftKey;

            let newWidth = initialWidth;
            let newHeight = initialHeight;
            let newLeft = initialLeft;
            let newTop = initialTop;

            const deltaX = e.clientX - initialX;
            const deltaY = e.clientY - initialY;

            switch (handleType) {
                case 'br':
                    newWidth = initialWidth + deltaX;
                    newHeight = shiftPressed ? newWidth / aspectRatio : initialHeight + deltaY;
                    break;
                case 'bl':
                    newWidth = initialWidth - deltaX;
                    newHeight = shiftPressed ? newWidth / aspectRatio : initialHeight + deltaY;
                    newLeft = initialLeft + deltaX;
                    break;
                case 'tr':
                    newWidth = initialWidth + deltaX;
                    newHeight = shiftPressed ? newWidth / aspectRatio : initialHeight - deltaY;
                    newTop = initialTop + (shiftPressed ? (initialHeight - newHeight) : deltaY);
                    break;
                case 'tl':
                    newWidth = initialWidth - deltaX;
                    newHeight = shiftPressed ? newWidth / aspectRatio : initialHeight - deltaY;
                    newLeft = initialLeft + deltaX;
                    newTop = initialTop + (shiftPressed ? (initialHeight - newHeight) : deltaY);
                    break;
                case 'rc':
                    newWidth = initialWidth + deltaX;
                    break;
                case 'lc':
                    newWidth = initialWidth - deltaX;
                    newLeft = initialLeft + deltaX;
                    break;
                case 'bc':
                    newHeight = initialHeight + deltaY;
                    break;
                case 'tc':
                    newHeight = initialHeight - deltaY;
                    newTop = initialTop + deltaY;
                    break;
            }

            const minWidth = parseFloat(getComputedStyle(resizableOverlayWrapper).minWidth);
            const minHeight = parseFloat(getComputedStyle(resizableOverlayWrapper).minHeight);

            // Apply min width constraints and adjust position if needed
            if (newWidth < minWidth) {
                if (handleType.includes('l')) { // If resizing from left, adjust left position
                    newLeft = newLeft + (initialWidth - minWidth);
                }
                newWidth = minWidth;
            }

            // Apply min height constraints and adjust position if needed
            if (newHeight < minHeight) {
                if (handleType.includes('t')) { // If resizing from top, adjust top position
                    newTop = newTop + (initialHeight - minHeight);
                }
                newHeight = minHeight;
            }

            // Envia as novas dimens√µes e posi√ß√£o para o processo principal do Electron
            if (window.electronAPI && window.electronAPI.setBounds) {
                window.electronAPI.setBounds(OVERLAY_NAME, {
                    x: Math.round(newLeft),
                    y: Math.round(newY), // Corrigido para usar newY
                    width: Math.round(newWidth),
                    height: Math.round(newHeight)
                });
            } else {
                // Fallback para ambiente de navegador
                resizableOverlayWrapper.style.width = newWidth + 'px';
                resizableOverlayWrapper.style.height = newHeight + 'px';
                resizableOverlayWrapper.style.left = newLeft + 'px';
                resizableOverlayWrapper.style.top = newTop + 'px';
            }
            resizeCanvas(); // Redesenha o canvas para se ajustar ao novo tamanho
        }

        // L√≥gica para iniciar o arrasto da overlay
        const header = document.querySelector('.header');
        header.addEventListener('mousedown', async (e) => {
            // Verifica se o clique n√£o foi em um controle (bot√£o)
            if (e.target.closest('.controls') || locked) return;

            isDragging = true;
            dragStartX = e.clientX;
            dragStartY = e.clientY;

            if (window.electronAPI && window.electronAPI.getBounds) {
                const bounds = await window.electronAPI.getBounds(OVERLAY_NAME);
                windowStartX = bounds.x;
                windowStartY = bounds.y;
            } else {
                const rect = resizableOverlayWrapper.getBoundingClientRect();
                windowStartX = rect.left;
                windowStartY = rect.top;
            }
            document.body.style.cursor = 'grabbing'; // Altera o cursor
        });

        // L√≥gica de movimento da overlay
        function dragMove(e) {
            if (!isDragging) return;

            const deltaX = e.clientX - dragStartX;
            const deltaY = e.clientY - dragStartY;

            const newX = windowStartX + deltaX;
            const newY = windowStartY + deltaY;

            // Se a API Electron estiver dispon√≠vel, usa setBounds para atualizar a janela
            if (window.electronAPI && window.electronAPI.setBounds) {
                window.electronAPI.setBounds(OVERLAY_NAME, {
                    x: Math.round(newX),
                    y: Math.round(newY),
                    width: Math.round(resizableOverlayWrapper.offsetWidth),
                    height: Math.round(resizableOverlayWrapper.offsetHeight)
                });
            } else {
                // Caso contr√°rio, atualiza os estilos CSS diretamente
                resizableOverlayWrapper.style.left = newX + 'px';
                resizableOverlayWrapper.style.top = newY + 'px';
            }
        }

        // Event listeners globais para mousemove e mouseup
        document.addEventListener('mousemove', (e) => {
            if (isResizing) {
                resize(e, resizeHandleType);
            } else if (isDragging) {
                dragMove(e);
            }
        });

        document.addEventListener('mouseup', () => {
            isResizing = false;
            isDragging = false;
            document.body.style.cursor = ''; // Restaura o cursor padr√£o
        });

        // Listener para receber a atualiza√ß√£o de bounds do main process (ap√≥s redimensionamento ou movimento externo)
        if (window.electronAPI && window.electronAPI.onUpdateBounds) {
            window.electronAPI.onUpdateBounds((bounds) => { // Removido 'event' pois n√£o √© usado
                // Atualiza o tamanho e a posi√ß√£o do wrapper HTML para sincronizar com a janela do Electron.
                resizableOverlayWrapper.style.width = `${bounds.width}px`;
                resizableOverlayWrapper.style.height = `${bounds.height}px`;
                resizableOverlayWrapper.style.left = `${bounds.x}px`; // Sincroniza a posi√ß√£o X
                resizableOverlayWrapper.style.top = `${bounds.y}px`;   // Sincroniza a posi√ß√£o Y
                resizeCanvas(); // Redesenha o canvas para se ajustar ao novo tamanho
            });
        }

        // Ajusta o tamanho inicial do wrapper quando a overlay √© carregada
        window.addEventListener('load', async () => {
            if (window.electronAPI && window.electronAPI.getBounds) {
                const initialBounds = await window.electronAPI.getBounds(OVERLAY_NAME);
                if (initialBounds) { // Verifica se bounds foram retornadas
                    resizableOverlayWrapper.style.width = `${initialBounds.width}px`;
                    resizableOverlayWrapper.style.height = `${initialBounds.height}px`;
                    resizableOverlayWrapper.style.left = `${initialBounds.x}px`;
                    resizableOverlayWrapper.style.top = `${initialBounds.y}px`;
                }
            }
            resizeCanvas(); // Garante que o canvas seja redimensionado corretamente no carregamento
        });


        // FECHAR A OVERLAY
        document.getElementById('closeBtn').onclick = () => {
            if (window.electronAPI && window.electronAPI.closeOverlay) {
                window.electronAPI.closeOverlay(OVERLAY_NAME); // Passa o nome da overlay
            } else {
                console.log("Bot√£o de fechar clicado. Em um ambiente de navegador, isso tentaria fechar a janela.");
                window.close();
            }
        };

        // AJUSTES: OPACIDADE E CONTRASTE
        const settingsPopover = document.getElementById('settings-popover');
        const rangeOpacity = document.getElementById('rangeOpacity');
        const rangeContrast = document.getElementById('rangeContrast');

        // Abre/fecha o popover de ajustes ao clicar no bot√£o de engrenagem
        document.getElementById('gear').onclick = (e) => {
            settingsPopover.style.display = settingsPopover.style.display === 'none' ? 'block' : 'none';
            settingsPopover.style.right = (window.innerWidth - e.target.getBoundingClientRect().right + 10) + 'px';
        };

        // Atualiza a opacidade da overlay
        rangeOpacity.oninput = async (e) => {
            const opacity = parseFloat(e.target.value);
            resizableOverlayWrapper.style.opacity = opacity;
            if (window.electronAPI && window.electronAPI.saveOverlaySettings) {
                const currentSettings = await window.electronAPI.loadOverlaySettings(OVERLAY_NAME) || {};
                currentSettings.opacity = opacity;
                window.electronAPI.saveOverlaySettings(OVERLAY_NAME, currentSettings);
            }
        };

        // Atualiza o contraste da overlay
        rangeContrast.oninput = async (e) => {
            const contrast = parseFloat(e.target.value);
            resizableOverlayWrapper.style.filter = `contrast(${contrast})`;
            if (window.electronAPI && window.electronAPI.saveOverlaySettings) {
                const currentSettings = await window.electronAPI.loadOverlaySettings(OVERLAY_NAME) || {};
                currentSettings.contrast = contrast;
                window.electronAPI.saveOverlaySettings(OVERLAY_NAME, currentSettings);
            }
        };

        // Carrega as configura√ß√µes salvas ao iniciar
        (async function loadSettings() {
            if (window.electronAPI && window.electronAPI.loadOverlaySettings) {
                const savedSettings = await window.electronAPI.loadOverlaySettings(OVERLAY_NAME);
                if (savedSettings) {
                    if (typeof savedSettings.opacity !== 'undefined') {
                        rangeOpacity.value = savedSettings.opacity;
                        resizableOverlayWrapper.style.opacity = savedSettings.opacity;
                    }
                    if (typeof savedSettings.contrast !== 'undefined') {
                        rangeContrast.value = savedSettings.contrast;
                        resizableOverlayWrapper.style.filter = `contrast(${savedSettings.contrast})`;
                    }
                }
            }
        })();

        // Fecha o popover de ajustes ao clicar fora dele
        document.addEventListener('mousedown', (e) => {
            if (settingsPopover.style.display === 'block' && !settingsPopover.contains(e.target) && e.target.id !== 'gear') {
                settingsPopover.style.display = 'none';
            }
        });

        // PIN: SEMPRE NO TOPO
        let pinned = false;
        const pinButton = document.getElementById('pin');
        pinButton.addEventListener('click', async () => {
            pinned = !pinned;
            pinButton.style.background = pinned ? '#60a5fa' : '#334155';
            pinButton.textContent = pinned ? 'üìç' : 'üìå';
            if (window.electronAPI && window.electronAPI.setAlwaysOnTop) {
                await window.electronAPI.setAlwaysOnTop(OVERLAY_NAME, pinned); // Passa o nome da overlay
            }
            if (window.electronAPI && window.electronAPI.saveOverlaySettings) {
                const currentSettings = await window.electronAPI.loadOverlaySettings(OVERLAY_NAME) || {};
                currentSettings.pinned = pinned;
                window.electronAPI.saveOverlaySettings(OVERLAY_NAME, currentSettings);
            }
        });
        // Define o estado inicial do bot√£o ao carregar (carrega do store)
        (async () => {
            if (window.electronAPI && window.electronAPI.loadOverlaySettings) {
                const savedSettings = await window.electronAPI.loadOverlaySettings(OVERLAY_NAME);
                if (savedSettings && typeof savedSettings.pinned !== 'undefined') {
                    pinned = savedSettings.pinned;
                    pinButton.style.background = pinned ? '#60a5fa' : '#334155';
                    pinButton.textContent = pinned ? 'üìç' : 'üìå';
                    if (window.electronAPI && window.electronAPI.setAlwaysOnTop) {
                        await window.electronAPI.setAlwaysOnTop(OVERLAY_NAME, pinned);
                    }
                }
            }
        })();


        // LOCK: TRAVAR MOVER/REDIMENSIONAR
        let locked = false;
        const lockButton = document.getElementById('lock');
        const allHandles = document.querySelectorAll('.resize-handle');
        lockButton.addEventListener('click', async () => {
            locked = !locked;
            lockButton.style.background = locked ? '#22d3ee' : '#334155';
            lockButton.textContent = locked ? 'üîì' : 'üîí';

            allHandles.forEach(handle => {
                handle.style.display = locked ? 'none' : 'block';
            });

            header.style.cursor = locked ? 'default' : 'grab';

            if (window.electronAPI && window.electronAPI.toggleMovable) {
                await window.electronAPI.toggleMovable(OVERLAY_NAME, !locked); // Passa o nome da overlay
            }
            if (window.electronAPI && window.electronAPI.saveOverlaySettings) {
                const currentSettings = await window.electronAPI.loadOverlaySettings(OVERLAY_NAME) || {};
                currentSettings.locked = locked;
                window.electronAPI.saveOverlaySettings(OVERLAY_NAME, currentSettings);
            }
        });
        // Define o estado inicial do bot√£o ao carregar (carrega do store)
        (async () => {
            if (window.electronAPI && window.electronAPI.loadOverlaySettings) {
                const savedSettings = await window.electronAPI.loadOverlaySettings(OVERLAY_NAME);
                if (savedSettings && typeof savedSettings.locked !== 'undefined') {
                    locked = savedSettings.locked;
                    lockButton.style.background = locked ? '#22d3ee' : '#334155';
                    lockButton.textContent = locked ? 'üîì' : 'üîí';
                    allHandles.forEach(handle => {
                        handle.style.display = locked ? 'none' : 'block';
                    });
                    header.style.cursor = locked ? 'default' : 'grab';
                    if (window.electronAPI && window.electronAPI.toggleMovable) {
                        await window.electronAPI.toggleMovable(OVERLAY_NAME, !locked);
                    }
                }
            }
        })();


        // CLICK: IGNORAR CLIQUES (CLICK-THROUGH)
        let ignoreClicks = false;
        const clickButton = document.getElementById('click');
        clickButton.addEventListener('click', async () => {
            ignoreClicks = !ignoreClicks;
            clickButton.style.background = ignoreClicks ? '#6366f1' : '#334155';
            clickButton.textContent = ignoreClicks ? 'üö´üñ±Ô∏è' : 'üñ±Ô∏è';

            overlayContent.style.pointerEvents = ignoreClicks ? 'none' : 'auto'; // Ajustado para overlayContent

            resizableOverlayWrapper.style.pointerEvents = 'auto'; // Wrapper sempre interativo
            header.style.pointerEvents = 'auto'; // Header sempre interativo
            document.querySelectorAll('.controls button').forEach(btn => btn.style.pointerEvents = 'auto');
            allHandles.forEach(handle => handle.style.pointerEvents = 'auto');
            settingsPopover.style.pointerEvents = 'auto';

            if (window.electronAPI && window.electronAPI.toggleClickThrough) {
                await window.electronAPI.toggleClickThrough(OVERLAY_NAME, ignoreClicks); // Passa o nome da overlay
            }
        });
        // Define o estado inicial do bot√£o ao carregar (carrega do store)
        (async () => {
            if (window.electronAPI && window.electronAPI.loadOverlaySettings) {
                const savedSettings = await window.electronAPI.loadOverlaySettings(OVERLAY_NAME);
                if (savedSettings && typeof savedSettings.ignoreClicks !== 'undefined') {
                    ignoreClicks = savedSettings.ignoreClicks;
                    clickButton.style.background = ignoreClicks ? '#6366f1' : '#334155';
                    clickButton.textContent = ignoreClicks ? 'üö´üñ±Ô∏è' : 'üñ±Ô∏è';
                    overlayContent.style.pointerEvents = ignoreClicks ? 'none' : 'auto'; // Ajustado para overlayContent
                    if (window.electronAPI && window.electronAPI.toggleClickThrough) {
                        await window.electronAPI.toggleClickThrough(OVERLAY_NAME, ignoreClicks);
                    }
                }
            }
        })();

        // --- L√≥gica de dados de input e Canvas ---
        // TIMELINE DOS INPUTS (Gr√°fico de linha no canvas)
        const timeline = { throttle: [], brake: [], steer: [], max: 100 }; // Armazena os √∫ltimos 100 valores
        const canvas = document.getElementById('inputTimelineCanvas');
        const ctx = canvas.getContext('2d');

        let throttle = 0, brake = 0, steer = 0; // Vari√°veis para os valores atuais dos inputs (ser√£o atualizadas pelo WebSocket)

        function drawTimeline(t, b, s) {
            // Adiciona os novos valores e remove os mais antigos se exceder o limite
            timeline.throttle.push(t); if (timeline.throttle.length > timeline.max) timeline.throttle.shift();
            timeline.brake.push(b);    if (timeline.brake.length > timeline.max) timeline.brake.shift();
            timeline.steer.push(s);    if (timeline.steer.length > timeline.max) timeline.steer.shift();

            // Redimensiona o canvas para preencher a largura dispon√≠vel do wrapper
            const w = canvas.width = resizableOverlayWrapper.clientWidth - 14; // -14 para padding/borda
            const h = canvas.height = 106; // Altura fixa do canvas (ajustado)

            ctx.clearRect(0, 0, w, h); // Limpa o canvas

            // --- Desenha o fundo e a linha de Acelera√ß√£o (verde) ---
            ctx.beginPath();
            timeline.throttle.forEach((v, i) => {
                ctx.lineTo(i * w / timeline.max, h - (v * h));
            });
            ctx.lineTo(w, h); // Vai para o canto inferior direito
            ctx.lineTo(0, h); // Vai para o canto inferior esquerdo
            ctx.closePath();
            ctx.fillStyle = "rgba(34, 197, 94, 0.2)"; // Cor verde com 20% de opacidade
            ctx.fill(); // Preenche a √°rea

            ctx.beginPath();
            ctx.strokeStyle = "#22c55e"; // Cor verde Tailwind
            ctx.lineWidth = 2;
            timeline.throttle.forEach((v, i) => {
                ctx.lineTo(i * w / timeline.max, h - (v * h));
            });
            ctx.stroke();

            // --- Desenha o fundo e a linha de Freio (vermelho) ---
            ctx.beginPath();
            timeline.brake.forEach((v, i) => {
                ctx.lineTo(i * w / timeline.max, h - (v * h));
            });
            ctx.lineTo(w, h); // Vai para o canto inferior direito
            ctx.lineTo(0, h); // Vai para o canto inferior esquerdo
            ctx.closePath();
            ctx.fillStyle = "rgba(239, 68, 68, 0.2)"; // Cor vermelha com 20% de opacidade
            ctx.fill(); // Preenche a √°rea

            ctx.beginPath();
            ctx.strokeStyle = "#ef4444"; // Cor vermelha Tailwind
            ctx.lineWidth = 2;
            timeline.brake.forEach((v, i) => {
                ctx.lineTo(i * w / timeline.max, h - (v * h));
            });
            ctx.stroke();

            // --- Desenha a linha de Dire√ß√£o (azul, centralizada) ---
            ctx.beginPath();
            ctx.strokeStyle = "#3b82f6"; // Cor azul Tailwind
            ctx.lineWidth = 2;
            timeline.steer.forEach((v, i) => {
                ctx.lineTo(i * w / timeline.max, h / 2 - (v * h / 2));
            });
            ctx.stroke();
        }

        // Fun√ß√£o para redimensionar o canvas quando a janela √© redimensionada
        function resizeCanvas() {
            // Chama drawTimeline com os valores atuais para redesenhar o gr√°fico
            drawTimeline(throttle, brake, steer);
        }

        // Adiciona event listener para redimensionamento da janela
        window.addEventListener('resize', resizeCanvas);

        // Chama resizeCanvas uma vez ao carregar a p√°gina para garantir o tamanho inicial correto
        window.onload = resizeCanvas;

        // URL do WebSocket, pode ser configurada externamente
        const WS_URL = window.OVERLAY_WS_URL || "ws://localhost:5221/ws";
        let socket;

        // Fun√ß√£o para atualizar os dados das barras e do canvas
        function updateOverlayData(d) {
            console.log("Dados recebidos do WebSocket:", d); // Log para depura√ß√£o

            // Converte e normaliza os valores de input para 0-100%
            throttle = Math.min(1, Math.max(0, (parseFloat(d.Throttle) || 0))); // Mant√©m 0-1 para o gr√°fico
            brake = Math.min(1, Math.max(0, (parseFloat(d.Brake) || 0)));       // Mant√©m 0-1 para o gr√°fico
            steer = Math.min(1, Math.max(-1, (parseFloat(d.SteeringWheelAngle) || 0))); // Mant√©m -1 a 1 para o gr√°fico

            // Atualiza as barras visuais
            const updateBar = (barId, labelId, val, isSteer = false) => { // Adicionado labelId
                const fill = document.getElementById(barId);
                const label = document.getElementById(labelId); // Seleciona o label diretamente pelo ID

                if (fill && label) {
                    let displayVal;
                    let calculatedWidth; // Vari√°vel para armazenar a largura calculada

                    if (isSteer) {
                        // Para o volante, exibe o valor ajustado (-100 a 100)
                        displayVal = (val * 100).toFixed(0);
                        label.textContent = (val > 0 ? '+' : '') + displayVal;
                        calculatedWidth = (val + 1) * 50; // Porcentagem para o CSS width (0-100%)
                        fill.style.width = calculatedWidth + "%";
                    } else {
                        displayVal = (val * 100).toFixed(0);
                        label.textContent = displayVal + '%';
                        calculatedWidth = val * 100; // Porcentagem para o CSS width (0-100%)
                        fill.style.width = calculatedWidth + "%";
                    }

                    // Ajusta a posi√ß√£o do r√≥tulo
                    // Garante que o r√≥tulo n√£o saia da barra
                    if (calculatedWidth < 15) { // Se a barra for muito pequena, mant√©m o r√≥tulo no in√≠cio
                        label.style.left = '4px';
                        label.style.transform = 'translateY(-50%)';
                    } else if (calculatedWidth > 85 && !isSteer) { // Para throttle/brake, se quase cheia, ajuste para n√£o transbordar
                         label.style.left = 'calc(100% - 4px)'; // 4px da borda direita
                         label.style.transform = 'translate(-100%, -50%)'; // Alinha a borda direita do r√≥tulo
                    } else if (isSteer && calculatedWidth > 85) { // Para steer, se quase cheia, ajuste para n√£o transbordar
                         label.style.left = 'calc(100% - 4px)'; // 4px da borda direita
                         label.style.transform = 'translate(-100%, -50%)'; // Alinha a borda direita do r√≥tulo
                    }
                    else { // Caso contr√°rio, posiciona no final do preenchimento da barra
                        label.style.left = calculatedWidth + '%';
                        label.style.transform = 'translate(-100%, -50%)'; // Alinha a borda direita do r√≥tulo com o final da barra
                    }
                } else {
                    console.warn(`Elemento de barra ou r√≥tulo n√£o encontrado: ${barId} ou ${labelId}`);
                }
            };

            updateBar("input-throttle", "throttle-value", throttle);
            updateBar("input-brake", "brake-value", brake);
            updateBar("input-steer", "steer-value", steer, true); // true para indicar que √© a barra de dire√ß√£o

            drawTimeline(throttle, brake, steer); // Agenda uma nova renderiza√ß√£o do canvas
        }

        // Inicializa a conex√£o WebSocket
        function initWebSocket() {
            socket = new WebSocket(WS_URL);
            socket.addEventListener("open", () => {
                console.log("üü¢ Conectado ao WebSocket");
            });
            socket.addEventListener("message", e => {
                try {
                    const msg = JSON.parse(e.data);
                    // Verifica se os dados recebidos s√£o v√°lidos antes de atualizar
                    if (msg && typeof msg.Throttle !== 'undefined') updateOverlayData(msg);
                    else console.warn("Dados inv√°lidos recebidos:", e.data);
                } catch (err) {
                    console.warn("Falha ao parsear dados JSON:", e.data, err);
                }
            });
            socket.addEventListener("close", () => {
                console.log("üî¥ Desconectado do WebSocket");
                // Tenta reconectar se a janela n√£o estiver oculta
                if (!document.hidden) setTimeout(initWebSocket, 3000);
            });
            socket.addEventListener("error", () => socket.close()); // Fecha em caso de erro
        }

        // Listener para visibilidade da p√°gina (pausa/retoma o WebSocket)
        document.addEventListener("visibilitychange", () => {
            if (document.hidden) {
                socket && socket.close(); // Fecha o WebSocket se a p√°gina estiver oculta
            } else if (!socket || socket.readyState !== 1) {
                initWebSocket(); // Reinicia o WebSocket se a p√°gina estiver vis√≠vel e n√£o conectada
            }
        });

        initWebSocket(); // Inicia o WebSocket ao carregar a p√°gina
    </script>
</body>
</html>
